{% extends "base.html" %}

{% block title %}Pose Skeleton Visualization{% endblock title %}

{% block content %}
<div class="container mx-auto px-4 py-8">
    <h1 class="text-3xl font-bold text-gray-800 mb-6">Pose Skeleton Visualization</h1>
    
    <div class="bg-white rounded-lg shadow-md p-6 mb-6">
        <h2 class="text-xl font-semibold mb-4 text-gray-700">Connection Settings</h2>
        <div class="flex items-center space-x-4">
            <label class="flex items-center">
                <span class="text-gray-700 mr-2">WebSocket URL:</span>
                <input type="text" id="websocket-url" value="{{ websocket_url }}" 
                       class="px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 w-96">
            </label>
            <button id="connect-btn" 
                    class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                Connect
            </button>
        </div>
    </div>

    <div class="bg-white rounded-lg shadow-md p-6 mb-6">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-semibold text-gray-700">Pose Visualization</h2>
            <div class="flex items-center space-x-2">
                <div id="status-indicator" class="w-3 h-3 rounded-full bg-red-500"></div>
                <span id="status-text" class="text-gray-600">Disconnected</span>
            </div>
        </div>
        
        <div class="relative bg-black rounded-lg" style="height: 600px;">
            <canvas id="pose-canvas" class="w-full h-full rounded-lg"></canvas>
            
            <!-- Controls overlay -->
            <div class="absolute top-4 left-4 bg-gray-800 bg-opacity-75 p-3 rounded-lg">
                <div class="text-white text-sm mb-2">
                    <div>FPS: <span id="fps-counter">0</span></div>
                    <div>Landmarks: <span id="landmark-count">0</span></div>
                </div>
            </div>
            
            <!-- Pose info overlay -->
            <div id="pose-info" class="absolute top-4 right-4 bg-gray-800 bg-opacity-75 p-3 rounded-lg text-white text-sm hidden">
                <div class="font-semibold mb-1">Pose Data</div>
                <div id="pose-details"></div>
            </div>
        </div>
    </div>

    <div class="bg-white rounded-lg shadow-md p-6">
        <h2 class="text-xl font-semibold mb-4 text-gray-700">Instructions</h2>
        <div class="text-gray-600 space-y-2">
            <p>1. Connect to a WebSocket that streams MediaPipe pose data in JSON format.</p>
            <p>2. The expected format is:</p>
            <pre class="bg-gray-100 p-3 rounded text-sm overflow-x-auto">
{
  "landmarks": [
    {"x": 0.5, "y": 0.3, "z": 0.0, "visibility": 0.9},
    ...
  ],
  "frame_number": 123,
  "timestamp": 1234567890
}
            </pre>
            <p>3. The pose skeleton will be rendered in real-time on the canvas above.</p>
            <p>4. Green dots represent landmarks, white lines represent connections.</p>
        </div>
    </div>
</div>
{% endblock content %}

{% block extra_js %}
<script>
class PoseSkeletonVisualizer {
    constructor() {
        this.canvas = document.getElementById('pose-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.socket = null;
        this.isConnected = false;
        this.lastFrameTime = 0;
        this.frameCount = 0;
        this.fps = 0;
        
        // MediaPipe Pose connections
        this.poseConnections = [
            [0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8],
            [9, 10], [11, 12], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21],
            [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [11, 23], [12, 24],
            [23, 24], [23, 25], [24, 26], [25, 27], [26, 28], [27, 29], [28, 30],
            [29, 31], [30, 32], [27, 31], [28, 32]
        ];
        
        this.setupCanvas();
        this.setupEventListeners();
        this.animate();
    }
    
    setupCanvas() {
        const resizeCanvas = () => {
            const container = this.canvas.parentElement;
            const rect = container.getBoundingClientRect();
            
            // Set canvas display size (CSS pixels)
            this.canvas.style.width = '100%';
            this.canvas.style.height = '100%';
            
            // Set canvas actual size in memory (scaled for retina displays)
            const dpr = window.devicePixelRatio || 1;
            this.canvas.width = rect.width * dpr;
            this.canvas.height = rect.height * dpr;
            
            // Scale the drawing context to match the device pixel ratio
            this.ctx.scale(dpr, dpr);
        };
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
    }
    
    setupEventListeners() {
        const connectBtn = document.getElementById('connect-btn');
        const wsUrlInput = document.getElementById('websocket-url');
        
        connectBtn.addEventListener('click', () => {
            if (this.isConnected) {
                this.disconnect();
            } else {
                this.connect(wsUrlInput.value);
            }
        });
        
        wsUrlInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                if (this.isConnected) {
                    this.disconnect();
                } else {
                    this.connect(wsUrlInput.value);
                }
            }
        });
    }
    
    connect(url) {
        try {
            this.socket = new WebSocket(url);
            this.updateStatus('connecting');
            
            this.socket.onopen = () => {
                this.isConnected = true;
                this.updateStatus('connected');
                document.getElementById('connect-btn').textContent = 'Disconnect';
                document.getElementById('connect-btn').classList.remove('bg-blue-500', 'hover:bg-blue-600');
                document.getElementById('connect-btn').classList.add('bg-red-500', 'hover:bg-red-600');
                console.log('WebSocket connected');
            };
            
            this.socket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    this.handlePoseData(data);
                } catch (error) {
                    console.error('Error parsing WebSocket message:', error);
                }
            };
            
            this.socket.onclose = () => {
                this.isConnected = false;
                this.updateStatus('disconnected');
                document.getElementById('connect-btn').textContent = 'Connect';
                document.getElementById('connect-btn').classList.remove('bg-red-500', 'hover:bg-red-600');
                document.getElementById('connect-btn').classList.add('bg-blue-500', 'hover:bg-blue-600');
                console.log('WebSocket disconnected');
            };
            
            this.socket.onerror = (error) => {
                console.error('WebSocket error:', error);
                this.updateStatus('error');
            };
            
        } catch (error) {
            console.error('Error creating WebSocket connection:', error);
            this.updateStatus('error');
        }
    }
    
    disconnect() {
        if (this.socket) {
            this.socket.close();
            this.socket = null;
        }
    }
    
    updateStatus(status) {
        const indicator = document.getElementById('status-indicator');
        const text = document.getElementById('status-text');
        
        indicator.classList.remove('bg-red-500', 'bg-yellow-500', 'bg-green-500');
        
        switch (status) {
            case 'connecting':
                indicator.classList.add('bg-yellow-500');
                text.textContent = 'Connecting...';
                break;
            case 'connected':
                indicator.classList.add('bg-green-500');
                text.textContent = 'Connected';
                break;
            case 'disconnected':
                indicator.classList.add('bg-red-500');
                text.textContent = 'Disconnected';
                break;
            case 'error':
                indicator.classList.add('bg-red-500');
                text.textContent = 'Connection Error';
                break;
        }
    }
    
    handlePoseData(data) {
        if (data.landmarks && Array.isArray(data.landmarks)) {
            this.currentLandmarks = data.landmarks;
            this.updateStats(data.landmarks.length);
            this.updatePoseInfo(data);
        }
    }
    
    updateStats(landmarkCount) {
        document.getElementById('landmark-count').textContent = landmarkCount;
        
        // Calculate FPS
        this.frameCount++;
        const currentTime = performance.now();
        if (currentTime - this.lastFrameTime >= 1000) {
            this.fps = Math.round(this.frameCount * 1000 / (currentTime - this.lastFrameTime));
            document.getElementById('fps-counter').textContent = this.fps;
            this.frameCount = 0;
            this.lastFrameTime = currentTime;
        }
    }
    
    updatePoseInfo(data) {
        const infoDiv = document.getElementById('pose-info');
        const detailsDiv = document.getElementById('pose-details');
        
        if (data.landmarks && data.landmarks.length > 0) {
            infoDiv.classList.remove('hidden');
            detailsDiv.innerHTML = `
                <div>Frame: ${data.frame_number || 'N/A'}</div>
                <div>Timestamp: ${data.timestamp || 'N/A'}</div>
                <div>Visible landmarks: ${data.landmarks.filter(l => l.visibility > 0.5).length}</div>
            `;
        } else {
            infoDiv.classList.add('hidden');
        }
    }
    
    drawPose() {
        if (!this.currentLandmarks || this.currentLandmarks.length === 0) {
            return;
        }
        
        // Get the display dimensions (CSS pixels)
        const container = this.canvas.parentElement;
        const rect = container.getBoundingClientRect();
        const width = rect.width;
        const height = rect.height;
        
        // Get the actual canvas dimensions (including device pixel ratio)
        const canvasWidth = this.canvas.width;
        const canvasHeight = this.canvas.height;
        
        // Clear canvas using actual canvas dimensions
        this.ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        
        // Scale landmarks to display size (CSS pixels)
        const scaledLandmarks = this.currentLandmarks.map(landmark => ({
            x: landmark.x * width,
            y: landmark.y * height,
            z: landmark.z || 0,
            visibility: landmark.visibility || 0
        }));
        
        // Draw connections
        this.ctx.strokeStyle = 'white';
        this.ctx.lineWidth = 2;
        
        this.poseConnections.forEach(([start, end]) => {
            if (scaledLandmarks[start] && scaledLandmarks[end] &&
                scaledLandmarks[start].visibility > 0.5 && scaledLandmarks[end].visibility > 0.5) {
                
                this.ctx.beginPath();
                this.ctx.moveTo(scaledLandmarks[start].x, scaledLandmarks[start].y);
                this.ctx.lineTo(scaledLandmarks[end].x, scaledLandmarks[end].y);
                this.ctx.stroke();
            }
        });
        
        // Draw landmarks
        scaledLandmarks.forEach((landmark, index) => {
            if (landmark.visibility > 0.5) {
                this.ctx.fillStyle = '#00ff00';
                this.ctx.beginPath();
                this.ctx.arc(landmark.x, landmark.y, 5, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Add landmark index for debugging
                this.ctx.fillStyle = 'white';
                this.ctx.font = '10px Arial';
                this.ctx.fillText(index.toString(), landmark.x + 8, landmark.y - 8);
            }
        });
    }
    
    animate() {
        this.drawPose();
        requestAnimationFrame(() => this.animate());
    }
}

// Initialize the visualizer when the page loads
document.addEventListener('DOMContentLoaded', () => {
    new PoseSkeletonVisualizer();
});
</script>
{% endblock extra_js %}