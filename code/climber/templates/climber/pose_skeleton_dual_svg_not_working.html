{% extends "base.html" %}

{% block title %}Dual Pose Skeleton Visualization{% endblock title %}

{% block content %}
<div class="container mx-auto px-4 py-8">
    <h1 class="text-3xl font-bold text-gray-800 mb-6">Dual Pose Skeleton Visualization</h1>
    
    <!-- View Mode Controls -->
    <div class="bg-white rounded-lg shadow-md p-6 mb-6">
        <h2 class="text-xl font-semibold mb-4 text-gray-700">View Mode</h2>
        <div class="flex flex-wrap gap-4">
            <button id="view-side-by-side" class="px-4 py-2 bg-indigo-500 text-white rounded-lg hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                Side by Side
            </button>
            <button id="view-combined" class="px-4 py-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600 focus:outline-none focus:ring-2 focus:ring-purple-500">
                Combined View
            </button>
            <button id="fullscreen-left" class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                Fullscreen Left
            </button>
            <button id="fullscreen-right" class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500">
                Fullscreen Right
            </button>
        </div>
    </div>
    
    <!-- Connection Settings for Both WebSockets -->
    <div class="bg-white rounded-lg shadow-md p-6 mb-6">
        <h2 class="text-xl font-semibold mb-4 text-gray-700">Connection Settings</h2>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <!-- Left WebSocket Settings -->
            <div class="border-r border-gray-200 pr-6">
                <h3 class="text-lg font-medium mb-3 text-gray-700">Left Visualization (Blue)</h3>
                <div class="flex items-center space-x-4">
                    <label class="flex items-center">
                        <span class="text-gray-700 mr-2">WebSocket URL:</span>
                        <input type="text" id="websocket-url-left" value="{{ websocket_url }}" 
                               class="px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 w-80">
                    </label>
                    <button id="connect-btn-left" 
                            class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        Connect
                    </button>
                </div>
            </div>
            
            <!-- Right WebSocket Settings -->
            <div class="pl-6">
                <h3 class="text-lg font-medium mb-3 text-gray-700">Right Visualization (Green)</h3>
                <div class="flex items-center space-x-4">
                    <label class="flex items-center">
                        <span class="text-gray-700 mr-2">WebSocket URL:</span>
                        <input type="text" id="websocket-url-right" value="{{ websocket_url }}" 
                               class="px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 w-80">
                    </label>
                    <button id="connect-btn-right" 
                            class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500">
                        Connect
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Wall Selection and SVG Overlay Settings -->
    <div class="bg-white rounded-lg shadow-md p-6 mb-6">
        <h2 class="text-xl font-semibold mb-4 text-gray-700">Wall Settings</h2>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <!-- Wall Selection -->
            <div>
                <h3 class="text-lg font-medium mb-3 text-gray-700">Select Wall</h3>
                <div class="flex items-center space-x-4">
                    <select id="wall-select" class="px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 flex-1">
                        <option value="">Loading walls...</option>
                    </select>
                    <button id="load-wall-btn"
                            class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500">
                        Load Wall
                    </button>
                </div>
                <div id="wall-status" class="mt-2 text-sm text-gray-600"></div>
            </div>
            
            <!-- SVG Overlay Settings -->
            <div>
                <h3 class="text-lg font-medium mb-3 text-gray-700">SVG Overlay (Right Side)</h3>
                <div class="flex items-center space-x-4">
                    <label class="flex items-center">
                        <input type="checkbox" id="show-svg-overlay" class="mr-2">
                        <span class="text-gray-700">Show SVG Overlay</span>
                    </label>
                    <div id="svg-opacity-control" class="flex items-center space-x-2 hidden">
                        <span class="text-gray-700">Opacity:</span>
                        <input type="range" id="svg-opacity" min="0" max="100" value="50"
                               class="w-24">
                        <span id="svg-opacity-value" class="text-gray-600">50%</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Side-by-Side Visualizations -->
    <div id="side-by-side-container" class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
        <!-- Left Visualization -->
        <div class="bg-white rounded-lg shadow-md p-6">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold text-gray-700">Left Pose Visualization</h2>
                <div class="flex items-center space-x-2">
                    <div id="status-indicator-left" class="w-3 h-3 rounded-full bg-red-500"></div>
                    <span id="status-text-left" class="text-gray-600">Disconnected</span>
                </div>
            </div>
            
            <div class="relative bg-black rounded-lg" style="height: 500px;">
                <canvas id="pose-canvas-left" class="w-full h-full rounded-lg"></canvas>
                
                <!-- Controls overlay -->
                <div class="absolute top-4 left-4 bg-gray-800 bg-opacity-75 p-3 rounded-lg">
                    <div class="text-white text-sm mb-2">
                        <div>FPS: <span id="fps-counter-left">0</span></div>
                        <div>Landmarks: <span id="landmark-count-left">0</span></div>
                    </div>
                </div>
                
                <!-- Pose info overlay -->
                <div id="pose-info-left" class="absolute top-4 right-4 bg-gray-800 bg-opacity-75 p-3 rounded-lg text-white text-sm hidden">
                    <div class="font-semibold mb-1">Pose Data</div>
                    <div id="pose-details-left"></div>
                </div>
            </div>
        </div>

        <!-- Right Visualization -->
        <div class="bg-white rounded-lg shadow-md p-6">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold text-gray-700">Right Pose Visualization</h2>
                <div class="flex items-center space-x-2">
                    <div id="status-indicator-right" class="w-3 h-3 rounded-full bg-red-500"></div>
                    <span id="status-text-right" class="text-gray-600">Disconnected</span>
                </div>
            </div>
            
            <div class="relative bg-black rounded-lg" style="height: 500px;">
                <canvas id="pose-canvas-right" class="w-full h-full rounded-lg"></canvas>
                
                <!-- SVG Overlay Canvas (hidden by default) -->
                <canvas id="svg-overlay-canvas" class="absolute top-0 left-0 w-full h-full pointer-events-none rounded-lg" style="display: none;"></canvas>
                
                <!-- Controls overlay -->
                <div class="absolute top-4 left-4 bg-gray-800 bg-opacity-75 p-3 rounded-lg">
                    <div class="text-white text-sm mb-2">
                        <div>FPS: <span id="fps-counter-right">0</span></div>
                        <div>Landmarks: <span id="landmark-count-right">0</span></div>
                        <div id="wall-info-right" class="hidden">Wall: <span id="wall-name-right"></span></div>
                    </div>
                </div>
                
                <!-- Pose info overlay -->
                <div id="pose-info-right" class="absolute top-4 right-4 bg-gray-800 bg-opacity-75 p-3 rounded-lg text-white text-sm hidden">
                    <div class="font-semibold mb-1">Pose Data</div>
                    <div id="pose-details-right"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Combined Visualization (Initially Hidden) -->
    <div id="combined-container" class="bg-white rounded-lg shadow-md p-6 mb-6 hidden">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-semibold text-gray-700">Combined Pose Visualization</h2>
            <div class="flex items-center space-x-4">
                <div class="flex items-center space-x-2">
                    <div class="w-3 h-3 rounded-full bg-blue-500"></div>
                    <span class="text-gray-600 text-sm">Left</span>
                    <div id="status-indicator-left-combined" class="w-3 h-3 rounded-full bg-red-500 ml-2"></div>
                    <span id="status-text-left-combined" class="text-gray-600 text-sm">Disconnected</span>
                </div>
                <div class="flex items-center space-x-2">
                    <div class="w-3 h-3 rounded-full bg-green-500"></div>
                    <span class="text-gray-600 text-sm">Right</span>
                    <div id="status-indicator-right-combined" class="w-3 h-3 rounded-full bg-red-500 ml-2"></div>
                    <span id="status-text-right-combined" class="text-gray-600 text-sm">Disconnected</span>
                </div>
            </div>
        </div>
        
        <div class="relative bg-black rounded-lg" style="height: 600px;">
            <canvas id="pose-canvas-combined" class="w-full h-full rounded-lg"></canvas>
            
            <!-- SVG Overlay Canvas for combined view (hidden by default) -->
            <canvas id="svg-overlay-canvas-combined" class="absolute top-0 left-0 w-full h-full pointer-events-none rounded-lg" style="display: none;"></canvas>
            
            <!-- Controls overlay -->
            <div class="absolute top-4 left-4 bg-gray-800 bg-opacity-75 p-3 rounded-lg">
                <div class="text-white text-sm mb-2">
                    <div>Left FPS: <span id="fps-counter-left-combined">0</span></div>
                    <div>Left Landmarks: <span id="landmark-count-left-combined">0</span></div>
                    <div>Right FPS: <span id="fps-counter-right-combined">0</span></div>
                    <div>Right Landmarks: <span id="landmark-count-right-combined">0</span></div>
                    <div id="wall-info-combined" class="hidden">Wall: <span id="wall-name-combined"></span></div>
                </div>
            </div>
            
            <!-- Pose info overlay -->
            <div id="pose-info-combined" class="absolute top-4 right-4 bg-gray-800 bg-opacity-75 p-3 rounded-lg text-white text-sm hidden">
                <div class="font-semibold mb-1">Pose Data</div>
                <div id="pose-details-combined"></div>
            </div>
        </div>
    </div>

    <!-- Fullscreen Left Visualization (Initially Hidden) -->
    <div id="fullscreen-left-container" class="bg-white rounded-lg shadow-md p-6 mb-6 hidden">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-semibold text-gray-700">Left Pose Visualization (Fullscreen)</h2>
            <div class="flex items-center space-x-2">
                <div id="status-indicator-left-fullscreen" class="w-3 h-3 rounded-full bg-red-500"></div>
                <span id="status-text-left-fullscreen" class="text-gray-600">Disconnected</span>
                <button id="exit-fullscreen-left" class="px-3 py-1 bg-gray-500 text-white rounded-lg hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 text-sm">
                    Exit Fullscreen
                </button>
            </div>
        </div>
        
        <div class="relative bg-black rounded-lg" style="height: 70vh;">
            <canvas id="pose-canvas-left-fullscreen" class="w-full h-full rounded-lg"></canvas>
            
            <!-- Controls overlay -->
            <div class="absolute top-4 left-4 bg-gray-800 bg-opacity-75 p-3 rounded-lg">
                <div class="text-white text-sm mb-2">
                    <div>FPS: <span id="fps-counter-left-fullscreen">0</span></div>
                    <div>Landmarks: <span id="landmark-count-left-fullscreen">0</span></div>
                </div>
            </div>
            
            <!-- Pose info overlay -->
            <div id="pose-info-left-fullscreen" class="absolute top-4 right-4 bg-gray-800 bg-opacity-75 p-3 rounded-lg text-white text-sm hidden">
                <div class="font-semibold mb-1">Pose Data</div>
                <div id="pose-details-left-fullscreen"></div>
            </div>
        </div>
    </div>

    <!-- Fullscreen Right Visualization (Initially Hidden) -->
    <div id="fullscreen-right-container" class="bg-white rounded-lg shadow-md p-6 mb-6 hidden">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-semibold text-gray-700">Right Pose Visualization (Fullscreen)</h2>
            <div class="flex items-center space-x-2">
                <div id="status-indicator-right-fullscreen" class="w-3 h-3 rounded-full bg-red-500"></div>
                <span id="status-text-right-fullscreen" class="text-gray-600">Disconnected</span>
                <button id="exit-fullscreen-right" class="px-3 py-1 bg-gray-500 text-white rounded-lg hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 text-sm">
                    Exit Fullscreen
                </button>
            </div>
        </div>
        
        <div class="relative bg-black rounded-lg" style="height: 70vh;">
            <canvas id="pose-canvas-right-fullscreen" class="w-full h-full rounded-lg"></canvas>
            
            <!-- SVG Overlay Canvas for fullscreen right view (hidden by default) -->
            <canvas id="svg-overlay-canvas-right-fullscreen" class="absolute top-0 left-0 w-full h-full pointer-events-none rounded-lg" style="display: none;"></canvas>
            
            <!-- Controls overlay -->
            <div class="absolute top-4 left-4 bg-gray-800 bg-opacity-75 p-3 rounded-lg">
                <div class="text-white text-sm mb-2">
                    <div>FPS: <span id="fps-counter-right-fullscreen">0</span></div>
                    <div>Landmarks: <span id="landmark-count-right-fullscreen">0</span></div>
                    <div id="wall-info-right-fullscreen" class="hidden">Wall: <span id="wall-name-right-fullscreen"></span></div>
                </div>
            </div>
            
            <!-- Pose info overlay -->
            <div id="pose-info-right-fullscreen" class="absolute top-4 right-4 bg-gray-800 bg-opacity-75 p-3 rounded-lg text-white text-sm hidden">
                <div class="font-semibold mb-1">Pose Data</div>
                <div id="pose-details-right-fullscreen"></div>
            </div>
        </div>
    </div>

    <div class="bg-white rounded-lg shadow-md p-6">
        <h2 class="text-xl font-semibold mb-4 text-gray-700">Instructions</h2>
        <div class="text-gray-600 space-y-2">
            <p>1. Connect to two WebSockets that stream pose data in JSON format.</p>
            <p>2. Select a wall from the dropdown and click "Load Wall" to enable SVG overlay functionality.</p>
            <p>3. Toggle "Show SVG Overlay" to display the transformed wall SVG on the right visualization.</p>
            <p>4. Adjust the opacity slider to control the transparency of the SVG overlay.</p>
            <p>5. The right visualization supports the new format from websocket_pose_session_tracker.py:</p>
            <pre class="bg-gray-100 p-3 rounded text-sm overflow-x-auto">
{
  "session": {
    "holds": [
      {"id": "hold_1", "type": "start", "status": "completed", "time": "2023-..."},
      ...
    ],
    "startTime": "2023-...Z",
    "endTime": null,
    "status": "started"
  },
  "pose": [
    {"x": 0.5, "y": 0.3, "z": 0.0, "visibility": 0.9},
    ...
  ]
}
            </pre>
            <p>6. The left visualization still supports the original format:</p>
            <pre class="bg-gray-100 p-3 rounded text-sm overflow-x-auto">
{
  "landmarks": [
    {"x": 0.5, "y": 0.3, "z": 0.0, "visibility": 0.9},
    ...
  ],
  "frame_number": 123,
  "timestamp": 1234567890
}
            </pre>
            <p>7. Choose your view mode:</p>
            <ul class="list-disc pl-6 space-y-1">
                <li><strong>Side by Side:</strong> View both poses in separate canvases</li>
                <li><strong>Combined View:</strong> View both poses overlaid on a single canvas (left pose in blue, right pose in green)</li>
                <li><strong>Fullscreen:</strong> View a single pose in fullscreen mode</li>
            </ul>
            <p>8. In combined view, left pose is rendered in blue and right pose in green for easy differentiation.</p>
            <p>9. The SVG overlay will be transformed using the wall's active calibration matrix to align with the pose data.</p>
            <p>10. The right visualization will display session information including completed holds when using the new format.</p>
        </div>
    </div>
</div>
{% endblock content %}

{% block extra_js %}
<script>
class PoseSkeletonVisualizer {
    constructor(side) {
        this.side = side; // 'left' or 'right'
        this.canvas = document.getElementById(`pose-canvas-${side}`);
        this.ctx = this.canvas.getContext('2d');
        this.socket = null;
        this.isConnected = false;
        this.lastFrameTime = 0;
        this.frameCount = 0;
        this.fps = 0;
        this.currentLandmarks = null;
        
        // Store the original canvas and context for fullscreen mode
        this.originalCanvas = this.canvas;
        this.originalCtx = this.ctx;
        
        // MediaPipe Pose connections
        this.poseConnections = [
            [0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8],
            [9, 10], [11, 12], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21],
            [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [11, 23], [12, 24],
            [23, 24], [23, 25], [24, 26], [25, 27], [26, 28], [27, 29], [28, 30],
            [29, 31], [30, 32], [27, 31], [28, 32]
        ];
        
        // Color scheme for this side
        this.colors = {
            left: {
                landmark: '#00aaff',  // Blue
                connection: '#66ccff'  // Light blue
            },
            right: {
                landmark: '#00ff00',  // Green
                connection: '#66ff66'  // Light green
            }
        };
        
        this.setupCanvas();
        this.loadSavedUrl();
        this.setupEventListeners();
        this.animate();
    }
    
    setupCanvas() {
        const resizeCanvas = () => {
            const container = this.canvas.parentElement;
            const rect = container.getBoundingClientRect();
            
            // Set canvas display size (CSS pixels)
            this.canvas.style.width = '100%';
            this.canvas.style.height = '100%';
            
            // Set canvas actual size in memory (scaled for retina displays)
            const dpr = window.devicePixelRatio || 1;
            this.canvas.width = rect.width * dpr;
            this.canvas.height = rect.height * dpr;
            
            // Scale the drawing context to match the device pixel ratio
            this.ctx.scale(dpr, dpr);
        };
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
    }
    
    loadSavedUrl() {
        const wsUrlInput = document.getElementById(`websocket-url-${this.side}`);
        const savedUrl = localStorage.getItem(`pose-skeleton-dual-${this.side}-url`);
        
        if (savedUrl) {
            wsUrlInput.value = savedUrl;
        }
    }
    
    saveUrl(url) {
        localStorage.setItem(`pose-skeleton-dual-${this.side}-url`, url);
    }
    
    setupEventListeners() {
        const connectBtn = document.getElementById(`connect-btn-${this.side}`);
        const wsUrlInput = document.getElementById(`websocket-url-${this.side}`);
        
        // Save URL to localStorage when it changes
        wsUrlInput.addEventListener('input', () => {
            this.saveUrl(wsUrlInput.value);
        });
        
        connectBtn.addEventListener('click', () => {
            if (this.isConnected) {
                this.disconnect();
            } else {
                this.saveUrl(wsUrlInput.value); // Save URL before connecting
                this.connect(wsUrlInput.value);
            }
        });
        
        wsUrlInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                if (this.isConnected) {
                    this.disconnect();
                } else {
                    this.saveUrl(wsUrlInput.value); // Save URL before connecting
                    this.connect(wsUrlInput.value);
                }
            }
        });
    }
    
    connect(url) {
        try {
            this.socket = new WebSocket(url);
            this.updateStatus('connecting');
            
            this.socket.onopen = () => {
                this.isConnected = true;
                this.updateStatus('connected');
                const connectBtn = document.getElementById(`connect-btn-${this.side}`);
                connectBtn.textContent = 'Disconnect';
                
                // Update button styling based on side
                if (this.side === 'left') {
                    connectBtn.classList.remove('bg-blue-500', 'hover:bg-blue-600');
                    connectBtn.classList.add('bg-red-500', 'hover:bg-red-600');
                } else {
                    connectBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                    connectBtn.classList.add('bg-red-500', 'hover:bg-red-600');
                }
                
                console.log(`${this.side} WebSocket connected`);
            };
            
            this.socket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    this.handlePoseData(data);
                    //console.log(data)
                } catch (error) {
                    console.error(`Error parsing ${this.side} WebSocket message:`, error);
                }
            };
            
            this.socket.onclose = () => {
                this.isConnected = false;
                this.updateStatus('disconnected');
                const connectBtn = document.getElementById(`connect-btn-${this.side}`);
                connectBtn.textContent = 'Connect';
                
                // Update button styling based on side
                if (this.side === 'left') {
                    connectBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
                    connectBtn.classList.add('bg-blue-500', 'hover:bg-blue-600');
                } else {
                    connectBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
                    connectBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                }
                
                console.log(`${this.side} WebSocket disconnected`);
            };
            
            this.socket.onerror = (error) => {
                console.error(`${this.side} WebSocket error:`, error);
                this.updateStatus('error');
            };
            
        } catch (error) {
            console.error(`Error creating ${this.side} WebSocket connection:`, error);
            this.updateStatus('error');
        }
    }
    
    disconnect() {
        if (this.socket) {
            this.socket.close();
            this.socket = null;
        }
    }
    
    updateStatus(status) {
        // Update all status indicators for this side
        const indicators = [
            `status-indicator-${this.side}`,
            `status-indicator-${this.side}-combined`,
            `status-indicator-${this.side}-fullscreen`
        ];
        
        const texts = [
            `status-text-${this.side}`,
            `status-text-${this.side}-combined`,
            `status-text-${this.side}-fullscreen`
        ];
        
        indicators.forEach(id => {
            const indicator = document.getElementById(id);
            if (indicator) {
                indicator.classList.remove('bg-red-500', 'bg-yellow-500', 'bg-green-500');
                
                switch (status) {
                    case 'connecting':
                        indicator.classList.add('bg-yellow-500');
                        break;
                    case 'connected':
                        indicator.classList.add('bg-green-500');
                        break;
                    case 'disconnected':
                    case 'error':
                        indicator.classList.add('bg-red-500');
                        break;
                }
            }
        });
        
        texts.forEach(id => {
            const text = document.getElementById(id);
            if (text) {
                switch (status) {
                    case 'connecting':
                        text.textContent = 'Connecting...';
                        break;
                    case 'connected':
                        text.textContent = 'Connected';
                        break;
                    case 'disconnected':
                        text.textContent = 'Disconnected';
                        break;
                    case 'error':
                        text.textContent = 'Connection Error';
                        break;
                }
            }
        });
    }
    
    handlePoseData(data) {
        // Handle the new JSON format from websocket_pose_session_tracker.py
        if (data.pose && Array.isArray(data.pose)) {
            this.currentLandmarks = data.pose;
            this.updateStats(data.pose.length);
            this.updatePoseInfo(data);
        } else if (data.landmarks && Array.isArray(data.landmarks)) {
            // Fallback to original format for backward compatibility
            this.currentLandmarks = data.landmarks;
            this.updateStats(data.landmarks.length);
            this.updatePoseInfo(data);
        }
    }
    
    updateStats(landmarkCount) {
        // Update all counters for this side
        const counters = [
            `landmark-count-${this.side}`,
            `landmark-count-${this.side}-combined`,
            `landmark-count-${this.side}-fullscreen`
        ];
        
        counters.forEach(id => {
            const counter = document.getElementById(id);
            if (counter) {
                counter.textContent = landmarkCount;
            }
        });
        
        // Calculate FPS
        this.frameCount++;
        const currentTime = performance.now();
        if (currentTime - this.lastFrameTime >= 1000) {
            this.fps = Math.round(this.frameCount * 1000 / (currentTime - this.lastFrameTime));
            
            const fpsCounters = [
                `fps-counter-${this.side}`,
                `fps-counter-${this.side}-combined`,
                `fps-counter-${this.side}-fullscreen`
            ];
            
            fpsCounters.forEach(id => {
                const counter = document.getElementById(id);
                if (counter) {
                    counter.textContent = this.fps;
                }
            });
            
            this.frameCount = 0;
            this.lastFrameTime = currentTime;
        }
    }
    
    updatePoseInfo(data) {
        // Update all pose info for this side
        const infoDivs = [
            `pose-info-${this.side}`,
            `pose-info-${this.side}-fullscreen`
        ];
        
        const detailsDivs = [
            `pose-details-${this.side}`,
            `pose-details-${this.side}-fullscreen`
        ];
        
        infoDivs.forEach((id, index) => {
            const infoDiv = document.getElementById(id);
            const detailsDiv = document.getElementById(detailsDivs[index]);
            
            if (infoDiv && detailsDiv) {
                const landmarks = data.pose || data.landmarks; // Handle both new and old formats
                if (landmarks && landmarks.length > 0) {
                    infoDiv.classList.remove('hidden');
                    
                    // Handle new format with session data
                    if (data.session) {
                        const session = data.session;
                        const completedHolds = session.holds ? session.holds.filter(h => h.status === 'completed').length : 0;
                        const totalHolds = session.holds ? session.holds.length : 0;
                        
                        detailsDiv.innerHTML = `
                            <div>Session Status: ${session.status || 'Unknown'}</div>
                            <div>Completed Holds: ${completedHolds}/${totalHolds}</div>
                            <div>Visible landmarks: ${landmarks.filter(l => l.visibility > 0.5).length}</div>
                            ${session.startTime ? `<div>Start: ${new Date(session.startTime).toLocaleTimeString()}</div>` : ''}
                        `;
                    }
                    // Fallback to original format
                    else {
                        detailsDiv.innerHTML = `
                            <div>Frame: ${data.frame_number || 'N/A'}</div>
                            <div>Timestamp: ${data.timestamp || 'N/A'}</div>
                            <div>Visible landmarks: ${landmarks.filter(l => l.visibility > 0.5).length}</div>
                        `;
                    }
                } else {
                    infoDiv.classList.add('hidden');
                }
            }
        });
    }
    
    drawPose() {
        if (!this.currentLandmarks || this.currentLandmarks.length === 0) {
            return;
        }
        
        // Get the display dimensions (CSS pixels)
        const container = this.canvas.parentElement;
        const rect = container.getBoundingClientRect();
        const width = rect.width;
        const height = rect.height;
        
        // Get the actual canvas dimensions (including device pixel ratio)
        const canvasWidth = this.canvas.width;
        const canvasHeight = this.canvas.height;
        
        // Clear canvas using actual canvas dimensions
        this.ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        
        // Scale landmarks to display size (CSS pixels)
        // The context is already scaled by device pixel ratio, so we use CSS dimensions
        const scaledLandmarks = this.currentLandmarks.map(landmark => ({
            x: landmark.x * width,
            y: landmark.y * height,
            z: landmark.z || 0,
            visibility: landmark.visibility || 0
        }));
        
        // Filter out landmarks that are outside the canvas bounds
        const visibleLandmarks = scaledLandmarks.filter(landmark => {
            return landmark.x >= 0 && landmark.x <= width &&
                   landmark.y >= 0 && landmark.y <= height &&
                   landmark.visibility > 0.5;
        });
        
        // If no landmarks are visible, return early
        if (visibleLandmarks.length === 0) {
            return;
        }
        
        // Get colors for this side
        const colors = this.colors[this.side];
        
        // Draw connections
        this.ctx.strokeStyle = colors.connection;
        this.ctx.lineWidth = 2;
        
        this.poseConnections.forEach(([start, end]) => {
            if (scaledLandmarks[start] && scaledLandmarks[end] &&
                scaledLandmarks[start].visibility > 0.5 && scaledLandmarks[end].visibility > 0.5 &&
                // Check if both landmarks are within canvas bounds
                scaledLandmarks[start].x >= 0 && scaledLandmarks[start].x <= width &&
                scaledLandmarks[start].y >= 0 && scaledLandmarks[start].y <= height &&
                scaledLandmarks[end].x >= 0 && scaledLandmarks[end].x <= width &&
                scaledLandmarks[end].y >= 0 && scaledLandmarks[end].y <= height) {
                
                this.ctx.beginPath();
                this.ctx.moveTo(scaledLandmarks[start].x, scaledLandmarks[start].y);
                this.ctx.lineTo(scaledLandmarks[end].x, scaledLandmarks[end].y);
                this.ctx.stroke();
            }
        });
        
        // Draw landmarks
        scaledLandmarks.forEach((landmark, index) => {
            if (landmark.visibility > 0.5 &&
                // Check if landmark is within canvas bounds
                landmark.x >= 0 && landmark.x <= width &&
                landmark.y >= 0 && landmark.y <= height) {
                
                this.ctx.fillStyle = colors.landmark;
                this.ctx.beginPath();
                this.ctx.arc(landmark.x, landmark.y, 5, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Add landmark index for debugging
                this.ctx.fillStyle = 'white';
                this.ctx.font = '10px Arial';
                this.ctx.fillText(index.toString(), landmark.x + 8, landmark.y - 8);
            }
        });
    }
    
    animate() {
        this.drawPose();
        requestAnimationFrame(() => this.animate());
    }
}

class CombinedPoseVisualizer {
    constructor(leftVisualizer, rightVisualizer) {
        this.canvas = document.getElementById('pose-canvas-combined');
        this.ctx = this.canvas.getContext('2d');
        this.leftVisualizer = leftVisualizer;
        this.rightVisualizer = rightVisualizer;
        
        // MediaPipe Pose connections
        this.poseConnections = [
            [0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8],
            [9, 10], [11, 12], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21],
            [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [11, 23], [12, 24],
            [23, 24], [23, 25], [24, 26], [25, 27], [26, 28], [27, 29], [28, 30],
            [29, 31], [30, 32], [27, 31], [28, 32]
        ];
        
        this.setupCanvas();
        this.animate();
    }
    
    setupCanvas() {
        const resizeCanvas = () => {
            const container = this.canvas.parentElement;
            const rect = container.getBoundingClientRect();
            
            // Set canvas display size (CSS pixels)
            this.canvas.style.width = '100%';
            this.canvas.style.height = '100%';
            
            // Set canvas actual size in memory (scaled for retina displays)
            const dpr = window.devicePixelRatio || 1;
            this.canvas.width = rect.width * dpr;
            this.canvas.height = rect.height * dpr;
            
            // Scale the drawing context to match the device pixel ratio
            this.ctx.scale(dpr, dpr);
        };
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
    }
    
    drawPose(landmarks, side) {
        if (!landmarks || landmarks.length === 0) {
            return;
        }
        
        // Get the display dimensions (CSS pixels)
        const container = this.canvas.parentElement;
        const rect = container.getBoundingClientRect();
        const width = rect.width;
        const height = rect.height;
        
        // Scale landmarks to display size (CSS pixels)
        // The context is already scaled by device pixel ratio, so we use CSS dimensions
        const scaledLandmarks = landmarks.map(landmark => ({
            x: landmark.x * width,
            y: landmark.y * height,
            z: landmark.z || 0,
            visibility: landmark.visibility || 0
        }));
        
        // Filter out landmarks that are outside the canvas bounds
        const visibleLandmarks = scaledLandmarks.filter(landmark => {
            return landmark.x >= 0 && landmark.x <= width &&
                   landmark.y >= 0 && landmark.y <= height &&
                   landmark.visibility > 0.5;
        });
        
        // If no landmarks are visible, return early
        if (visibleLandmarks.length === 0) {
            return;
        }
        
        // Get colors for this side
        const colors = side === 'left' ? 
            { landmark: '#00aaff', connection: '#66ccff' } :  // Blue
            { landmark: '#00ff00', connection: '#66ff66' };   // Green
        
        // Draw connections
        this.ctx.strokeStyle = colors.connection;
        this.ctx.lineWidth = 2;
        
        this.poseConnections.forEach(([start, end]) => {
            if (scaledLandmarks[start] && scaledLandmarks[end] &&
                scaledLandmarks[start].visibility > 0.5 && scaledLandmarks[end].visibility > 0.5 &&
                // Check if both landmarks are within canvas bounds
                scaledLandmarks[start].x >= 0 && scaledLandmarks[start].x <= width &&
                scaledLandmarks[start].y >= 0 && scaledLandmarks[start].y <= height &&
                scaledLandmarks[end].x >= 0 && scaledLandmarks[end].x <= width &&
                scaledLandmarks[end].y >= 0 && scaledLandmarks[end].y <= height) {
                
                this.ctx.beginPath();
                this.ctx.moveTo(scaledLandmarks[start].x, scaledLandmarks[start].y);
                this.ctx.lineTo(scaledLandmarks[end].x, scaledLandmarks[end].y);
                this.ctx.stroke();
            }
        });
        
        // Draw landmarks
        scaledLandmarks.forEach((landmark, index) => {
            if (landmark.visibility > 0.5 &&
                // Check if landmark is within canvas bounds
                landmark.x >= 0 && landmark.x <= width &&
                landmark.y >= 0 && landmark.y <= height) {
                
                this.ctx.fillStyle = colors.landmark;
                this.ctx.beginPath();
                this.ctx.arc(landmark.x, landmark.y, 5, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Add landmark index for debugging
                this.ctx.fillStyle = 'white';
                this.ctx.font = '10px Arial';
                this.ctx.fillText(index.toString(), landmark.x + 8, landmark.y - 8);
            }
        });
    }
    
    animate() {
        // Clear canvas
        const container = this.canvas.parentElement;
        const rect = container.getBoundingClientRect();
        const canvasWidth = this.canvas.width;
        const canvasHeight = this.canvas.height;
        
        this.ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        
        // Draw left pose (blue)
        if (this.leftVisualizer.currentLandmarks) {
            this.drawPose(this.leftVisualizer.currentLandmarks, 'left');
        }
        
        // Draw right pose (green)
        if (this.rightVisualizer.currentLandmarks) {
            this.drawPose(this.rightVisualizer.currentLandmarks, 'right');
        }
        
        requestAnimationFrame(() => this.animate());
    }
}

class ViewModeManager {
    constructor(leftVisualizer, rightVisualizer) {
        this.leftVisualizer = leftVisualizer;
        this.rightVisualizer = rightVisualizer;
        this.combinedVisualizer = null;
        this.currentMode = 'side-by-side';
        this.wallSVGManager = null;
        
        this.setupEventListeners();
    }
    
    setWallSVGManager(wallSVGManager) {
        this.wallSVGManager = wallSVGManager;
    }
    
    setupEventListeners() {
        // View mode buttons
        document.getElementById('view-side-by-side').addEventListener('click', () => {
            this.showSideBySide();
        });
        
        document.getElementById('view-combined').addEventListener('click', () => {
            this.showCombined();
        });
        
        document.getElementById('fullscreen-left').addEventListener('click', () => {
            this.showFullscreenLeft();
        });
        
        document.getElementById('fullscreen-right').addEventListener('click', () => {
            this.showFullscreenRight();
        });
        
        // Exit fullscreen buttons
        document.getElementById('exit-fullscreen-left').addEventListener('click', () => {
            this.exitFullscreen();
            this.showSideBySide();
        });
        
        document.getElementById('exit-fullscreen-right').addEventListener('click', () => {
            this.exitFullscreen();
            this.showSideBySide();
        });
        
        // Add ESC key listener to exit fullscreen
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' &&
                (this.currentMode === 'fullscreen-left' || this.currentMode === 'fullscreen-right')) {
                this.exitFullscreen();
                this.showSideBySide();
            }
        });
    }
    
    showSideBySide() {
        this.currentMode = 'side-by-side';
        
        // Hide all containers
        document.getElementById('combined-container').classList.add('hidden');
        document.getElementById('fullscreen-left-container').classList.add('hidden');
        document.getElementById('fullscreen-right-container').classList.add('hidden');
        
        // Show side-by-side container
        document.getElementById('side-by-side-container').classList.remove('hidden');
        
        // Redraw SVG overlay if needed
        if (this.wallSVGManager && this.wallSVGManager.showOverlay) {
            setTimeout(() => this.wallSVGManager.drawSVGOverlay(), 100);
        }
        
        // Update button styles
        this.updateButtonStyles('side-by-side');
    }
    
    showCombined() {
        this.currentMode = 'combined';
        
        // Hide all containers
        document.getElementById('side-by-side-container').classList.add('hidden');
        document.getElementById('fullscreen-left-container').classList.add('hidden');
        document.getElementById('fullscreen-right-container').classList.add('hidden');
        
        // Show combined container
        document.getElementById('combined-container').classList.remove('hidden');
        
        // Initialize combined visualizer if not already done
        if (!this.combinedVisualizer) {
            this.combinedVisualizer = new CombinedPoseVisualizer(this.leftVisualizer, this.rightVisualizer);
        }
        
        // Redraw SVG overlay if needed
        if (this.wallSVGManager && this.wallSVGManager.showOverlay) {
            setTimeout(() => this.wallSVGManager.drawSVGOverlay(), 100);
        }
        
        // Update button styles
        this.updateButtonStyles('combined');
    }
    
    showFullscreenLeft() {
        this.currentMode = 'fullscreen-left';
        
        // Hide all containers
        document.getElementById('side-by-side-container').classList.add('hidden');
        document.getElementById('combined-container').classList.add('hidden');
        document.getElementById('fullscreen-right-container').classList.add('hidden');
        
        // Show left fullscreen container
        document.getElementById('fullscreen-left-container').classList.remove('hidden');
        
        // Setup fullscreen canvas if not already done
        this.setupFullscreenCanvas('left');
        
        // Enter true fullscreen mode
        this.enterFullscreen('fullscreen-left-container');
        
        // Update button styles
        this.updateButtonStyles('fullscreen-left');
    }
    
    showFullscreenRight() {
        this.currentMode = 'fullscreen-right';
        
        // Hide all containers
        document.getElementById('side-by-side-container').classList.add('hidden');
        document.getElementById('combined-container').classList.add('hidden');
        document.getElementById('fullscreen-left-container').classList.add('hidden');
        
        // Show right fullscreen container
        document.getElementById('fullscreen-right-container').classList.remove('hidden');
        
        // Setup fullscreen canvas if not already done
        this.setupFullscreenCanvas('right');
        
        // Enter true fullscreen mode
        this.enterFullscreen('fullscreen-right-container');
        
        // Redraw SVG overlay if needed
        if (this.wallSVGManager && this.wallSVGManager.showOverlay) {
            setTimeout(() => this.wallSVGManager.drawSVGOverlay(), 100);
        }
        
        // Update button styles
        this.updateButtonStyles('fullscreen-right');
    }
    
    enterFullscreen(elementId) {
        const element = document.getElementById(elementId);
        
        // Handle fullscreen for different browsers
        const requestFullscreen = element.requestFullscreen ||
                              element.webkitRequestFullscreen ||
                              element.mozRequestFullScreen ||
                              element.msRequestFullscreen;
        
        if (requestFullscreen) {
            requestFullscreen.call(element);
        }
        
        // Add fullscreen change listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', this.handleFullscreenChange);
    }
    
    exitFullscreen() {
        const exitFullscreen = document.exitFullscreen ||
                            document.webkitExitFullscreen ||
                            document.mozCancelFullScreen ||
                            document.msExitFullscreen;
        
        if (exitFullscreen) {
            exitFullscreen.call(document);
        }
    }
    
    handleFullscreenChange = () => {
        const isFullscreen = document.fullscreenElement ||
                          document.webkitFullscreenElement ||
                          document.mozFullScreenElement ||
                          document.msFullscreenElement;
        
        // If exiting fullscreen, return to side-by-side view
        if (!isFullscreen) {
            this.showSideBySide();
        }
    }
    
    setupFullscreenCanvas(side) {
        const canvas = document.getElementById(`pose-canvas-${side}-fullscreen`);
        const ctx = canvas.getContext('2d');
        
        // Check if already initialized
        if (canvas.dataset.initialized === 'true') {
            return;
        }
        
        // Mark as initialized
        canvas.dataset.initialized = 'true';
        
        // Setup canvas resize
        const resizeCanvas = () => {
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            
            // Set canvas display size (CSS pixels)
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            
            // Set canvas actual size in memory (scaled for retina displays)
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            
            // Scale the drawing context to match the device pixel ratio
            ctx.scale(dpr, dpr);
        };
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Setup animation loop
        const visualizer = side === 'left' ? this.leftVisualizer : this.rightVisualizer;
        const originalCanvas = visualizer.canvas;
        const originalCtx = visualizer.ctx;
        
        const animate = () => {
            if (this.currentMode !== `fullscreen-${side}`) {
                return; // Stop animating if not in this mode
            }
            
            // Get the display dimensions (CSS pixels)
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            
            // Get the actual canvas dimensions (including device pixel ratio)
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Clear canvas using actual canvas dimensions
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            // Draw pose if available
            if (visualizer.currentLandmarks && visualizer.currentLandmarks.length > 0) {
                // Scale landmarks to display size (CSS pixels)
                // The context is already scaled by device pixel ratio, so we use CSS dimensions
                const scaledLandmarks = visualizer.currentLandmarks.map(landmark => ({
                    x: landmark.x * width,
                    y: landmark.y * height,
                    z: landmark.z || 0,
                    visibility: landmark.visibility || 0
                }));
                
                // Filter out landmarks that are outside the canvas bounds
                const visibleLandmarks = scaledLandmarks.filter(landmark => {
                    return landmark.x >= 0 && landmark.x <= width &&
                           landmark.y >= 0 && landmark.y <= height &&
                           landmark.visibility > 0.5;
                });
                
                // If no landmarks are visible, continue animation
                if (visibleLandmarks.length > 0) {
                    // Get colors for this side
                    const colors = side === 'left' ?
                        { landmark: '#00aaff', connection: '#66ccff' } :  // Blue
                        { landmark: '#00ff00', connection: '#66ff66' };   // Green
                    
                    // Draw connections
                    ctx.strokeStyle = colors.connection;
                    ctx.lineWidth = 2;
                    
                    visualizer.poseConnections.forEach(([start, end]) => {
                        if (scaledLandmarks[start] && scaledLandmarks[end] &&
                            scaledLandmarks[start].visibility > 0.5 && scaledLandmarks[end].visibility > 0.5 &&
                            // Check if both landmarks are within canvas bounds
                            scaledLandmarks[start].x >= 0 && scaledLandmarks[start].x <= width &&
                            scaledLandmarks[start].y >= 0 && scaledLandmarks[start].y <= height &&
                            scaledLandmarks[end].x >= 0 && scaledLandmarks[end].x <= width &&
                            scaledLandmarks[end].y >= 0 && scaledLandmarks[end].y <= height) {
                            
                            ctx.beginPath();
                            ctx.moveTo(scaledLandmarks[start].x, scaledLandmarks[start].y);
                            ctx.lineTo(scaledLandmarks[end].x, scaledLandmarks[end].y);
                            ctx.stroke();
                        }
                    });
                    
                    // Draw landmarks
                    scaledLandmarks.forEach((landmark, index) => {
                        if (landmark.visibility > 0.5 &&
                            // Check if landmark is within canvas bounds
                            landmark.x >= 0 && landmark.x <= width &&
                            landmark.y >= 0 && landmark.y <= height) {
                            
                            ctx.fillStyle = colors.landmark;
                            ctx.beginPath();
                            ctx.arc(landmark.x, landmark.y, 5, 0, 2 * Math.PI);
                            ctx.fill();
                            
                            // Add landmark index for debugging
                            ctx.fillStyle = 'white';
                            ctx.font = '10px Arial';
                            ctx.fillText(index.toString(), landmark.x + 8, landmark.y - 8);
                        }
                    });
                }
            }
            
            requestAnimationFrame(animate);
        };
        
        animate();
    }
    
    updateButtonStyles(activeMode) {
        // Reset all button styles
        document.getElementById('view-side-by-side').classList.remove('bg-indigo-700');
        document.getElementById('view-combined').classList.remove('bg-purple-700');
        document.getElementById('fullscreen-left').classList.remove('bg-blue-700');
        document.getElementById('fullscreen-right').classList.remove('bg-green-700');
        
        // Highlight active button
        switch (activeMode) {
            case 'side-by-side':
                document.getElementById('view-side-by-side').classList.add('bg-indigo-700');
                break;
            case 'combined':
                document.getElementById('view-combined').classList.add('bg-purple-700');
                break;
            case 'fullscreen-left':
                document.getElementById('fullscreen-left').classList.add('bg-blue-700');
                break;
            case 'fullscreen-right':
                document.getElementById('fullscreen-right').classList.add('bg-green-700');
                break;
        }
    }
}

// Wall and SVG Overlay Management
class WallSVGManager {
    constructor() {
        this.walls = [];
        this.selectedWall = null;
        this.svgData = null;
        this.calibrationMatrix = null;
        this.showOverlay = false;
        this.opacity = 0.5;
        
        this.loadWalls();
        this.setupEventListeners();
    }
    
    async loadWalls() {
        try {
            // Fetch walls from API
            const response = await fetch('/api/walls/');
            if (!response.ok) {
                throw new Error('Failed to fetch walls');
            }
            
            const data = await response.json();
            this.walls = data.results || data;
            
            // Populate wall select dropdown
            const wallSelect = document.getElementById('wall-select');
            wallSelect.innerHTML = '<option value="">Select a wall...</option>';
            
            this.walls.forEach(wall => {
                const option = document.createElement('option');
                option.value = wall.id;
                option.textContent = wall.name;
                wallSelect.appendChild(option);
            });
            
        } catch (error) {
            console.error('Error loading walls:', error);
            document.getElementById('wall-status').textContent = 'Error loading walls';
        }
    }
    
    async loadWall(wallId) {
        if (!wallId) {
            this.selectedWall = null;
            this.svgData = null;
            this.calibrationMatrix = null;
            this.updateWallStatus('No wall selected');
            return;
        }
        
        try {
            // Find wall in cached data
            this.selectedWall = this.walls.find(w => w.id == wallId);
            
            if (!this.selectedWall) {
                throw new Error('Wall not found');
            }
            
            // Load calibrated SVG data
            const response = await fetch(`/calibration/wall/${wallId}/svg-data/`);
            if (!response.ok) {
                throw new Error('Failed to load wall calibration data');
            }
            
            const data = await response.json();
            
            if (!data.success) {
                throw new Error(data.error || 'No calibration data available');
            }
            
            this.svgData = data;
            this.calibrationMatrix = data.calibration.perspective_transform;
            
            // Update wall info displays
            this.updateWallInfo(this.selectedWall.name);
            this.updateWallStatus(`Loaded: ${this.selectedWall.name}`);
            
            // If overlay is enabled, redraw it
            if (this.showOverlay) {
                this.drawSVGOverlay();
            }
            
        } catch (error) {
            console.error('Error loading wall:', error);
            this.updateWallStatus(`Error: ${error.message}`);
            this.selectedWall = null;
            this.svgData = null;
            this.calibrationMatrix = null;
        }
    }
    
    setupEventListeners() {
        // Load wall button
        document.getElementById('load-wall-btn').addEventListener('click', () => {
            const wallId = document.getElementById('wall-select').value;
            this.loadWall(wallId);
        });
        
        // SVG overlay toggle
        document.getElementById('show-svg-overlay').addEventListener('change', (e) => {
            this.showOverlay = e.target.checked;
            
            // Show/hide opacity control
            const opacityControl = document.getElementById('svg-opacity-control');
            if (this.showOverlay) {
                opacityControl.classList.remove('hidden');
            } else {
                opacityControl.classList.add('hidden');
            }
            
            // Show/hide all SVG overlay canvases
            const overlayCanvases = [
                'svg-overlay-canvas',
                'svg-overlay-canvas-combined',
                'svg-overlay-canvas-right-fullscreen'
            ];
            
            overlayCanvases.forEach(id => {
                const canvas = document.getElementById(id);
                if (canvas) {
                    canvas.style.display = this.showOverlay ? 'block' : 'none';
                }
            });
            
            // Draw or clear overlay
            if (this.showOverlay && this.svgData) {
                this.drawSVGOverlay();
            }
        });
        
        // Opacity slider
        document.getElementById('svg-opacity').addEventListener('input', (e) => {
            this.opacity = e.target.value / 100;
            document.getElementById('svg-opacity-value').textContent = `${e.target.value}%`;
            
            // Redraw overlay with new opacity
            if (this.showOverlay && this.svgData) {
                this.drawSVGOverlay();
            }
        });
    }
    
    updateWallStatus(message) {
        const statusElement = document.getElementById('wall-status');
        statusElement.textContent = message;
    }
    
    updateWallInfo(wallName) {
        // Update all wall info displays
        const wallNames = [
            'wall-name-right',
            'wall-name-combined',
            'wall-name-right-fullscreen'
        ];
        
        const wallInfos = [
            'wall-info-right',
            'wall-info-combined',
            'wall-info-right-fullscreen'
        ];
        
        wallNames.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.textContent = wallName;
            }
        });
        
        wallInfos.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.classList.remove('hidden');
            }
        });
    }
    
    drawSVGOverlay() {
        console.log('drawSVGOverlay called', {
            svgData: !!this.svgData,
            calibrationMatrix: !!this.calibrationMatrix,
            showOverlay: this.showOverlay
        });
        
        if (!this.svgData || !this.calibrationMatrix) {
            console.log('Missing SVG data or calibration matrix');
            return;
        }
        
        // Draw on all active overlay canvases
        this.drawSVGOnCanvas('svg-overlay-canvas');
        this.drawSVGOnCanvas('svg-overlay-canvas-combined');
        this.drawSVGOnCanvas('svg-overlay-canvas-right-fullscreen');
    }
    
    drawSVGOnCanvas(canvasId) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const container = canvas.parentElement;
        const rect = container.getBoundingClientRect();
        
        // Set canvas size
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.style.display = 'block'; // Ensure canvas is visible
        canvas.style.position = 'absolute'; // Ensure proper positioning
        canvas.style.top = '0';
        canvas.style.left = '0';
        
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        
        console.log(`Canvas ${canvasId} initialized:`, {
            width: rect.width,
            height: rect.height,
            dpr: dpr,
            canvasWidth: canvas.width,
            canvasHeight: canvas.height
        });
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Set opacity
        ctx.globalAlpha = this.opacity;
        
        // Draw wall image if available
        this.drawWallImage(ctx, rect.width, rect.height);
        
        // Apply perspective transformation and draw SVG paths
        this.drawTransformedSVG(ctx, rect.width, rect.height);
    }
    
    drawTransformedSVG(ctx, canvasWidth, canvasHeight) {
        console.log('drawTransformedSVG called', {
            hasPaths: !!this.svgData.paths,
            pathCount: this.svgData.paths ? Object.keys(this.svgData.paths).length : 0,
            matrix: this.calibrationMatrix
        });
        
        if (!this.svgData.paths) return;
        
        // Create transformation matrix from calibration data
        const matrix = this.calibrationMatrix;
        
        // Draw each path
        Object.values(this.svgData.paths).forEach((path, index) => {
            console.log(`Drawing path ${index}:`, path);
            if (!path.d) return;
            
            // Parse path and apply transformation
            this.drawTransformedPath(ctx, path.d, matrix, canvasWidth, canvasHeight);
        });
    }
    
    drawTransformedPath(ctx, pathD, matrix, canvasWidth, canvasHeight) {
        // Simple path parsing and transformation
        // This is a simplified implementation - in production, you'd want to use a proper SVG path parser
        
        // Parse path commands
        const commands = this.parsePathCommands(pathD);
        
        ctx.strokeStyle = '#ffffff';
        ctx.fillStyle = '#ffffff30';
        ctx.lineWidth = 2;
        
        // Draw a test rectangle to verify canvas is working
        ctx.fillRect(50, 50, 100, 100);
        
        ctx.beginPath();
        
        commands.forEach(cmd => {
            const [type, ...coords] = cmd;
            
            switch (type) {
                case 'M': // Move to
                    if (coords.length >= 2) {
                        const [x, y] = this.transformPoint(coords[0], coords[1], matrix, canvasWidth, canvasHeight);
                        if (x >= 0 && x <= canvasWidth && y >= 0 && y <= canvasHeight) {
                            ctx.moveTo(x, y);
                        }
                    }
                    break;
                    
                case 'L': // Line to
                    if (coords.length >= 2) {
                        for (let i = 0; i < coords.length; i += 2) {
                            const [x, y] = this.transformPoint(coords[i], coords[i + 1], matrix, canvasWidth, canvasHeight);
                            if (x >= 0 && x <= canvasWidth && y >= 0 && y <= canvasHeight) {
                                ctx.lineTo(x, y);
                            }
                        }
                    }
                    break;
                    
                case 'C': // Cubic Bezier curve
                    if (coords.length >= 6) {
                        for (let i = 0; i < coords.length; i += 6) {
                            const cp1x = coords[i], cp1y = coords[i + 1];
                            const cp2x = coords[i + 2], cp2y = coords[i + 3];
                            const endx = coords[i + 4], endy = coords[i + 5];
                            
                            const [cp1] = this.transformPoint(cp1x, cp1y, matrix, canvasWidth, canvasHeight);
                            const [cp2] = this.transformPoint(cp2x, cp2y, matrix, canvasWidth, canvasHeight);
                            const [end] = this.transformPoint(endx, endy, matrix, canvasWidth, canvasHeight);
                            
                            // Only draw if all points are within canvas bounds
                            if (cp1[0] >= 0 && cp1[0] <= canvasWidth && cp1[1] >= 0 && cp1[1] <= canvasHeight &&
                                cp2[0] >= 0 && cp2[0] <= canvasWidth && cp2[1] >= 0 && cp2[1] <= canvasHeight &&
                                end[0] >= 0 && end[0] <= canvasWidth && end[1] >= 0 && end[1] <= canvasHeight) {
                                ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], end[0], end[1]);
                            }
                        }
                    }
                    break;
                    
                case 'Z': // Close path
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.beginPath();
                    break;
            }
        });
    }
    
    drawWallImage(ctx, canvasWidth, canvasHeight) {
        if (!this.svgData || !this.svgData.wall_image_url) {
            return;
        }
        
        console.log('Drawing wall image:', this.svgData.wall_image_url);
        
        const img = new Image();
        img.onload = () => {
            // Draw image to fill canvas
            ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
            
            // Draw SVG paths on top of image
            this.drawTransformedSVG(ctx, canvasWidth, canvasHeight);
        };
        
        img.onerror = () => {
            console.error('Failed to load wall image:', this.svgData.wall_image_url);
        };
        
        img.src = this.svgData.wall_image_url;
    }
    
    parsePathCommands(pathD) {
        // Simple regex-based path parser
        // This is a basic implementation - consider using a proper SVG library for production
        const regex = /([MmLlHhVvCcSsQqTtAaZz])\s*([^MmLlHhVvCcSsQqTtAaZz]*)/g;
        const commands = [];
        let match;
        
        while ((match = regex.exec(pathD)) !== null) {
            const type = match[1];
            const coordsStr = match[2];
            const coords = [];
            
            // Extract numbers from coordinates string
            const numberRegex = /-?\d*\.?\d+/g;
            let numberMatch;
            while ((numberMatch = numberRegex.exec(coordsStr)) !== null) {
                coords.push(parseFloat(numberMatch[0]));
            }
            
            commands.push([type, ...coords]);
        }
        
        return commands;
    }
    
    transformPoint(x, y, matrix, canvasWidth, canvasHeight) {
        // Apply perspective transformation matrix
        // matrix is expected to be a 3x3 array in row-major order
        
        if (!matrix || matrix.length !== 3 || matrix[0].length !== 3) {
            // Fallback to simple scaling if no valid matrix
            return [x, y];
        }
        
        // Convert to homogeneous coordinates
        const w = matrix[2][0] * x + matrix[2][1] * y + matrix[2][2];
        
        if (Math.abs(w) < 0.0001) {
            // Point at infinity - return far away
            return [canvasWidth * 2, canvasHeight * 2];
        }
        
        const transformedX = (matrix[0][0] * x + matrix[0][1] * y + matrix[0][2]) / w;
        const transformedY = (matrix[1][0] * x + matrix[1][1] * y + matrix[1][2]) / w;
        
        // Log transformation for debugging
        if (Math.random() < 0.01) { // Only log 1% of points to avoid spam
            console.log('Transform point:', {
                original: [x, y],
                transformed: [transformedX, transformedY],
                w: w
            });
        }
        
        return [transformedX, transformedY];
    }
}

// Initialize the visualizers when the page loads
document.addEventListener('DOMContentLoaded', () => {
    const leftVisualizer = new PoseSkeletonVisualizer('left');
    const rightVisualizer = new PoseSkeletonVisualizer('right');
    const viewModeManager = new ViewModeManager(leftVisualizer, rightVisualizer);
    const wallSVGManager = new WallSVGManager();
    
    // Link the wall SVG manager to the view mode manager
    viewModeManager.setWallSVGManager(wallSVGManager);
});
</script>
{% endblock extra_js %}