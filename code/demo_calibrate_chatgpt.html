<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PNG ↔ SVG Calibrator</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; margin: 16px; }
    .container { position: relative; display: inline-block; border: 1px solid #ddd; }
    #img { display: block; max-width: 100%; height: auto; }
    svg.overlay { position: absolute; left: 0; top: 0; pointer-events: none; }
    .controls { margin-top: 12px; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    button, input[type=file] { padding:6px 10px; font-size:14px; }
    .point { cursor: move; pointer-events: auto; }
    .info { margin-top:12px; max-width:900px; white-space:pre-wrap; background:#f8f8f8;padding:10px;border-radius:6px;border:1px solid #eee }
    .matrix { font-family: monospace; }
    label{font-size:14px}
  </style>
</head>
<body>
  <h2>PNG ↔ SVG Calibrator</h2>
  <p>Load a PNG (or any image) then drag the four corner handles (red circles) to align the SVG over the image. Click <strong>Compute transform</strong> to get the homography matrix and mapping functions.</p>

  <div class="controls">
    <input id="file" type="file" accept="image/*" />
    <button id="reset">Reset corners</button>
    <button id="compute">Compute transform</button>
    <button id="invert">Invert (SVG → image)</button>
    <button id="export">Export matrix JSON</button>
    <label><input type="checkbox" id="show-grid" /> show svg grid</label>
  </div>

  <div id="stage" class="container">
    <img id="img" alt="drop or load image" src="" />
    <!-- SVG overlay sized dynamically to image -->
    <svg id="svg" class="overlay" xmlns="http://www.w3.org/2000/svg" width="0" height="0" viewBox="0 0 0 0" preserveAspectRatio="xMinYMin meet">
      <defs>
        <pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse">
          <path d="M40 0 L0 0 0 40" fill="none" stroke="#ccc" stroke-width="0.5" />
        </pattern>
      </defs>
      <rect id="gridRect" x="0" y="0" width="100%" height="100%" fill="url(#grid)" visibility="hidden" />
      <polygon id="quad" points="" fill="rgba(0,128,255,0.08)" stroke="#0078ff" stroke-width="2" />
      <!-- draggable handles -->
      <g id="handles"></g>
    </svg>
  </div>

  <div class="info" id="info"></div>

  <script>
    // Helper: create DOM element with namespace
    function svgEl(name) { return document.createElementNS('http://www.w3.org/2000/svg', name); }

    const fileInput = document.getElementById('file');
    const img = document.getElementById('img');
    const svg = document.getElementById('svg');
    const handlesG = document.getElementById('handles');
    const quad = document.getElementById('quad');
    const gridRect = document.getElementById('gridRect');
    const info = document.getElementById('info');
    const resetBtn = document.getElementById('reset');
    const computeBtn = document.getElementById('compute');
    const exportBtn = document.getElementById('export');
    const invertBtn = document.getElementById('invert');
    const showGrid = document.getElementById('show-grid');

    let imgNaturalWidth = 0, imgNaturalHeight = 0;

    // corner order: top-left, top-right, bottom-right, bottom-left
    let corners = [ {x:0,y:0}, {x:0,y:0}, {x:0,y:0}, {x:0,y:0} ];
    let H = null; // homography 3x3 matrix mapping image -> svg
    let Hinv = null;

    fileInput.addEventListener('change', e=>{
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      const url = URL.createObjectURL(f);
      img.src = url;
    });

    img.addEventListener('load', ()=>{
      // set svg overlay to image size
      imgNaturalWidth = img.naturalWidth;
      imgNaturalHeight = img.naturalHeight;
      const rect = img.getBoundingClientRect();
      svg.style.width = rect.width + 'px';
      svg.style.height = rect.height + 'px';
      svg.setAttribute('width', rect.width);
      svg.setAttribute('height', rect.height);
      svg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.height}`);
      // set initial corners to image corners (in displayed coordinates)
      corners = [ {x:0,y:0}, {x:rect.width,y:0}, {x:rect.width,y:rect.height}, {x:0,y:rect.height} ];
      renderHandles();
      updateQuad();
      writeInfo('Image loaded: ' + imgNaturalWidth + '×' + imgNaturalHeight + ' (displayed ' + Math.round(rect.width) + '×' + Math.round(rect.height) + ')');
    });

    resetBtn.addEventListener('click', ()=>{
      if (!img.src) return;
      const rect = img.getBoundingClientRect();
      corners = [ {x:0,y:0}, {x:rect.width,y:0}, {x:rect.width,y:rect.height}, {x:0,y:rect.height} ];
      H = Hinv = null;
      renderHandles(); updateQuad(); writeInfo('Corners reset.');
    });

    showGrid.addEventListener('change', ()=>{
      gridRect.style.visibility = showGrid.checked ? 'visible' : 'hidden';
    });

    function renderHandles(){
      handlesG.innerHTML = '';
      corners.forEach((c,i)=>{
        const g = svgEl('g');
        g.setAttribute('class','point');
        g.setAttribute('data-i', i);
        g.style.cursor = 'move';
        const circle = svgEl('circle');
        circle.setAttribute('cx', c.x);
        circle.setAttribute('cy', c.y);
        circle.setAttribute('r', 8);
        circle.setAttribute('fill', '#ff4d4d');
        circle.setAttribute('stroke', '#fff');
        circle.setAttribute('stroke-width', '2');
        circle.setAttribute('data-i', i);
        g.appendChild(circle);
        // label
        const t = svgEl('text');
        t.setAttribute('x', c.x + 12);
        t.setAttribute('y', c.y + 6);
        t.setAttribute('font-size', '12');
        t.textContent = ['TL','TR','BR','BL'][i];
        g.appendChild(t);
        handlesG.appendChild(g);

        makeDraggable(g);
      });
    }

    function updateQuad(){
      quad.setAttribute('points', corners.map(p=>p.x + ',' + p.y).join(' '));
    }

    function writeInfo(text){ info.textContent = text; }

    // Pointer dragging
    function makeDraggable(node){
      let dragging = false;
      let idx = Number(node.getAttribute('data-i'));

      node.addEventListener('pointerdown', (ev)=>{
        ev.preventDefault();
        (ev.target).setPointerCapture(ev.pointerId);
        dragging = true;
      });

      node.addEventListener('pointermove', (ev)=>{
        if (!dragging) return;
        const rect = svg.getBoundingClientRect();
        const x = ev.clientX - rect.left;
        const y = ev.clientY - rect.top;
        corners[idx].x = clamp(x, 0, rect.width);
        corners[idx].y = clamp(y, 0, rect.height);
        renderHandles(); updateQuad();
      });

      node.addEventListener('pointerup', (ev)=>{
        dragging = false;
        tryRelease(ev);
      });
      node.addEventListener('pointercancel', (ev)=>{ dragging = false; tryRelease(ev); });

      function tryRelease(ev){
        try{ ev.target.releasePointerCapture(ev.pointerId); }catch(e){}
      }
    }

    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    // Compute homography H mapping image-display coordinates -> svg coordinates (they are same system here) but user may want transform from original image pixels
    // We'll compute H that maps from image pixel coordinates to svg displayed coordinates.

    computeBtn.addEventListener('click', ()=>{
      if (!img.src) { writeInfo('Load an image first.'); return; }
      // image displayed rect
      const rect = img.getBoundingClientRect();
      // source corners in image pixel coordinates (natural image)
      const src = [ {x:0,y:0}, {x:imgNaturalWidth,y:0}, {x:imgNaturalWidth,y:imgNaturalHeight}, {x:0,y:imgNaturalHeight} ];
      const dst = corners.map(c=> ({x:c.x, y:c.y}) );
      H = computeHomography(src, dst);
      Hinv = invert3(H);
      if (!H) { writeInfo('Failed to compute homography'); return; }
      let out = 'Homography (image pixels -> svg displayed coords)\n';
      out += matrixToString(H);
      out += '\n\nUse imageToSVG(x,y) to map image pixel coordinates to svg coordinates.\nUse svgToImage(x,y) for the inverse.';
      writeInfo(out);
    });

    invertBtn.addEventListener('click', ()=>{
      if (!H) { writeInfo('Compute transform first.'); return; }
      // swap src/dst and recompute
      const src = corners.map(c=> ({x:c.x, y:c.y}) );
      const dst = [ {x:0,y:0}, {x:imgNaturalWidth,y:0}, {x:imgNaturalWidth,y:imgNaturalHeight}, {x:0,y:imgNaturalHeight} ];
      const H2 = computeHomography(src, dst);
      if (!H2) { writeInfo('Failed to invert via recompute.'); return; }
      Hinv = H2; // this maps svg displayed coords -> image pixels
      writeInfo('Computed inverse homography (svg displayed -> image pixels)\n' + matrixToString(Hinv));
    });

    exportBtn.addEventListener('click', ()=>{
      if (!H) { writeInfo('Compute transform first.'); return; }
      const obj = { H, Hinv, image: {naturalWidth: imgNaturalWidth, naturalHeight: imgNaturalHeight} };
      const blob = new Blob([JSON.stringify(obj, null, 2)], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'homography.json';
      a.click();
      URL.revokeObjectURL(url);
    });

    // Click test: click on svg to map to image pixels
    svg.addEventListener('click', (e)=>{
      if (!Hinv && !H) return;
      const rect = svg.getBoundingClientRect();
      const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      if (Hinv) {
        const p = applyHomography(Hinv, {x,y});
        writeInfo('SVG → image (pixels): ' + p.x.toFixed(2) + ', ' + p.y.toFixed(2));
      } else if (H) {
        const p = applyHomography(H, {x,y});
        writeInfo('image → svg: ' + p.x.toFixed(2) + ', ' + p.y.toFixed(2));
      }
    });

    // ---------- Linear algebra & homography ----------
    function computeHomography(src, dst){
      // src and dst: arrays of 4 points {x,y}
      // Build 8x8 system A*h = b where h is 8 unknowns (h11..h32), h33=1
      const A = [];
      const b = [];
      for (let i=0;i<4;i++){
        const xs = src[i].x, ys = src[i].y;
        const xd = dst[i].x, yd = dst[i].y;
        // two rows
        A.push([ xs, ys, 1, 0, 0, 0, -xs*xd, -ys*xd ]);
        b.push(xd);
        A.push([ 0, 0, 0, xs, ys, 1, -xs*yd, -ys*yd ]);
        b.push(yd);
      }
      const h8 = solveLinear(A,b);
      if (!h8) return null;
      const h = [
        [h8[0], h8[1], h8[2]],
        [h8[3], h8[4], h8[5]],
        [h8[6], h8[7], 1]
      ];
      return h;
    }

    function applyHomography(H, p){
      const x = p.x, y = p.y;
      const a = H;
      const wx = a[2][0]*x + a[2][1]*y + a[2][2];
      if (wx === 0) return {x:Infinity,y:Infinity};
      const nx = (a[0][0]*x + a[0][1]*y + a[0][2]) / wx;
      const ny = (a[1][0]*x + a[1][1]*y + a[1][2]) / wx;
      return {x: nx, y: ny};
    }

    function matrixToString(M){
      return M.map(r=> r.map(v=> v.toFixed(6).padStart(10)).join(' ')).join('\n');
    }

    function solveLinear(Aorig, borig){
      // simple Gauss-Jordan for small systems. Returns solution array or null.
      // Copy
      const A = Aorig.map(r=> r.slice());
      const b = borig.slice();
      const n = A.length; // here 8
      const m = A[0].length; // 8
      // augment
      for (let i=0;i<n;i++) A[i].push(b[i]);
      const N = n;
      const M = m+1;
      let row = 0;
      for (let col=0; col<m && row<N; col++){
        // find pivot
        let sel = row;
        for (let i=row;i<N;i++) if (Math.abs(A[i][col]) > Math.abs(A[sel][col])) sel = i;
        if (Math.abs(A[sel][col]) < 1e-12) continue;
        // swap
        const tmp = A[sel]; A[sel] = A[row]; A[row] = tmp;
        // normalize
        const div = A[row][col];
        for (let j=col;j<M;j++) A[row][j] /= div;
        // eliminate
        for (let i=0;i<N;i++){
          if (i===row) continue;
          const factor = A[i][col];
          if (Math.abs(factor) < 1e-15) continue;
          for (let j=col;j<M;j++) A[i][j] -= factor * A[row][j];
        }
        row++;
      }
      // read solution (first m columns)
      const sol = new Array(m).fill(0);
      for (let i=0;i<m;i++){
        // find row where pivot at column i is 1
        let found = -1;
        for (let r=0;r<N;r++){
          if (Math.abs(A[r][i]-1) < 1e-9){
            // check zeros elsewhere
            let othersZero = true;
            for (let c=0;c<m;c++) if (c!==i && Math.abs(A[r][c])>1e-8) othersZero = false;
            if (othersZero){ found = r; break; }
          }
        }
        if (found !== -1) sol[i] = A[found][M-1]; else sol[i] = 0;
      }
      return sol;
    }

    function invert3(M){
      // invert 3x3 matrix
      const a = M;
      const det = a[0][0]*(a[1][1]*a[2][2]-a[1][2]*a[2][1]) - a[0][1]*(a[1][0]*a[2][2]-a[1][2]*a[2][0]) + a[0][2]*(a[1][0]*a[2][1]-a[1][1]*a[2][0]);
      if (Math.abs(det) < 1e-15) return null;
      const invDet = 1/det;
      const inv = [[],[],[]];
      inv[0][0] =  (a[1][1]*a[2][2]-a[1][2]*a[2][1]) * invDet;
      inv[0][1] = -(a[0][1]*a[2][2]-a[0][2]*a[2][1]) * invDet;
      inv[0][2] =  (a[0][1]*a[1][2]-a[0][2]*a[1][1]) * invDet;
      inv[1][0] = -(a[1][0]*a[2][2]-a[1][2]*a[2][0]) * invDet;
      inv[1][1] =  (a[0][0]*a[2][2]-a[0][2]*a[2][0]) * invDet;
      inv[1][2] = -(a[0][0]*a[1][2]-a[0][2]*a[1][0]) * invDet;
      inv[2][0] =  (a[1][0]*a[2][1]-a[1][1]*a[2][0]) * invDet;
      inv[2][1] = -(a[0][0]*a[2][1]-a[0][1]*a[2][0]) * invDet;
      inv[2][2] =  (a[0][0]*a[1][1]-a[0][1]*a[1][0]) * invDet;
      return inv;
    }

    // Expose convenient functions on window for user scripting
    window.imageToSVG = function(x,y){
      if (!H) throw new Error('Compute transform first');
      return applyHomography(H, {x,y});
    }
    window.svgToImage = function(x,y){
      if (!Hinv) throw new Error('Compute inverse homography first (use Invert button)');
      return applyHomography(Hinv, {x,y});
    }

    // initial instructions
    writeInfo('Load an image using the file input. Then drag the four red handles to calibrate. Click Compute transform to get the homography matrix and use imageToSVG(x,y) in the console.');
  </script>
</body>
</html>
