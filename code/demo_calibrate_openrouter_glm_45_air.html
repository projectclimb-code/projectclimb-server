<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image-SVG Point Matching Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .point-marker {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #3b82f6;
            border: 2px solid white;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }
        
        .point-marker svg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .selectable-area {
            position: relative;
            cursor: crosshair;
        }
        
        .selectable-area svg {
            pointer-events: none;
        }
        
        .selectable-area svg * {
            pointer-events: none;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <header class="mb-8 text-center">
            <h1 class="text-3xl font-bold text-gray-800 mb-2">Image-SVG Point Matching Tool</h1>
            <p class="text-gray-600">Upload an image and SVG, then select corresponding points to transform the SVG</p>
        </header>

        <!-- File Upload Section -->
        <section class="mb-8 bg-white rounded-lg shadow-md p-6">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">Upload Files</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <label for="imageUpload" class="block text-sm font-medium text-gray-700 mb-2">Upload Image</label>
                    <input type="file" id="imageUpload" accept="image/*" class="block w-full text-sm text-gray-500
                        file:mr-4 file:py-2 file:px-4
                        file:rounded-md file:border-0
                        file:text-sm file:font-semibold
                        file:bg-blue-50 file:text-blue-700
                        hover:file:bg-blue-100
                    ">
                </div>
                <div>
                    <label for="svgUpload" class="block text-sm font-medium text-gray-700 mb-2">Upload SVG</label>
                    <input type="file" id="svgUpload" accept=".svg,image/svg+xml" class="block w-full text-sm text-gray-500
                        file:mr-4 file:py-2 file:px-4
                        file:rounded-md file:border-0
                        file:text-sm file:font-semibold
                        file:bg-green-50 file:text-green-700
                        hover:file:bg-green-100
                    ">
                </div>
            </div>
        </section>

        <!-- Display Section -->
        <section class="mb-8">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <!-- Image Display -->
                <div class="bg-white rounded-lg shadow-md p-4">
                    <h3 class="text-lg font-medium text-gray-700 mb-2">Original Image</h3>
                    <div id="imageContainer" class="selectable-area border border-gray-300 rounded-md overflow-hidden bg-gray-50">
                        <img id="uploadedImage" class="max-w-full h-auto" style="display: none;">
                        <div id="imagePlaceholder" class="flex items-center justify-center h-64 text-gray-400">
                            <p>Upload an image</p>
                        </div>
                    </div>
                    <div class="mt-2 text-sm text-gray-600">
                        Points selected: <span id="imagePointsCount">0</span>/4
                        <button id="clearImagePoints" class="ml-2 px-2 py-1 text-xs bg-red-500 text-white rounded hover:bg-red-600">Clear</button>
                    </div>
                </div>

                <!-- SVG Display -->
                <div class="bg-white rounded-lg shadow-md p-4">
                    <h3 class="text-lg font-medium text-gray-700 mb-2">Original SVG</h3>
                    <div id="svgContainer" class="selectable-area border border-gray-300 rounded-md overflow-hidden bg-gray-50">
                        <div id="uploadedSvg" class="max-w-full h-auto" style="display: none;"></div>
                        <div id="svgPlaceholder" class="flex items-center justify-center h-64 text-gray-400">
                            <p>Upload an SVG</p>
                        </div>
                    </div>
                    <div class="mt-2 text-sm text-gray-600">
                        Points selected: <span id="svgPointsCount">0</span>/4
                        <button id="clearSvgPoints" class="ml-2 px-2 py-1 text-xs bg-red-500 text-white rounded hover:bg-red-600">Clear</button>
                    </div>
                </div>

                <!-- Overlay Display -->
                <div class="bg-white rounded-lg shadow-md p-4">
                    <h3 class="text-lg font-medium text-gray-700 mb-2">SVG Overlay on Image</h3>
                    <div id="overlayContainer" class="border border-gray-300 rounded-md overflow-hidden bg-gray-50 relative">
                        <div id="overlayPlaceholder" class="flex items-center justify-center h-64 text-gray-400">
                            <p>Upload both files to see overlay</p>
                        </div>
                        <div id="overlayContent" class="relative" style="display: none;">
                            <img id="overlayImage" class="max-w-full h-auto">
                            <div id="overlaySvgContainer" class="absolute top-0 left-0 w-full h-full pointer-events-none">
                            </div>
                        </div>
                    </div>
                    <div class="mt-2 flex justify-between items-center">
                        <div class="text-sm text-gray-600">
                            <button id="applyTransformation" class="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:bg-gray-300" disabled>Apply Transformation</button>
                        </div>
                        <div class="text-sm text-gray-600">
                            <button id="clearOverlay" class="px-2 py-1 text-xs bg-red-500 text-white rounded hover:bg-red-600">Clear Overlay</button>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Controls Section -->
        <section class="bg-white rounded-lg shadow-md p-6">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">Controls</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <h3 class="text-md font-medium text-gray-700 mb-2">Transformation Settings</h3>
                    <div class="flex items-center mb-2">
                        <input type="radio" id="affineTransform" name="transformType" value="affine" class="mr-2" checked>
                        <label for="affineTransform" class="text-sm">Affine (3 points)</label>
                    </div>
                    <div class="flex items-center mb-4">
                        <input type="radio" id="perspectiveTransform" name="transformType" value="perspective" class="mr-2">
                        <label for="perspectiveTransform" class="text-sm">Perspective (4 points)</label>
                    </div>
                    <button id="resetAll" class="w-full px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">Reset All</button>
                </div>
                <div>
                    <h3 class="text-md font-medium text-gray-700 mb-2">Instructions</h3>
                    <ol class="text-sm text-gray-600 list-decimal pl-5 space-y-1">
                        <li>Upload an image and SVG file</li>
                        <li>Select corresponding points on both the image and SVG</li>
                        <li>Choose transformation type (3 or 4 points)</li>
                        <li>Click "Apply Transformation" to see the result</li>
                    </ol>
                </div>
            </div>
        </section>
    </div>

    <script>
        // State management
        const state = {
            image: null,
            svg: null,
            imagePoints: [],
            svgPoints: [],
            transformType: 'affine',
            isSelectingPoints: true
        };

        // DOM elements
        const imageUpload = document.getElementById('imageUpload');
        const svgUpload = document.getElementById('svgUpload');
        const uploadedImage = document.getElementById('uploadedImage');
        const uploadedSvg = document.getElementById('uploadedSvg');
        const imageContainer = document.getElementById('imageContainer');
        const svgContainer = document.getElementById('svgContainer');
        const overlayContainer = document.getElementById('overlayContainer');
        const overlayImage = document.getElementById('overlayImage');
        const overlaySvgContainer = document.getElementById('overlaySvgContainer');
        const imagePointsCount = document.getElementById('imagePointsCount');
        const svgPointsCount = document.getElementById('svgPointsCount');
        const applyTransformation = document.getElementById('applyTransformation');
        const clearOverlay = document.getElementById('clearOverlay');
        const clearImagePoints = document.getElementById('clearImagePoints');
        const clearSvgPoints = document.getElementById('clearSvgPoints');
        const resetAll = document.getElementById('resetAll');
        const affineTransform = document.getElementById('affineTransform');
        const perspectiveTransform = document.getElementById('perspectiveTransform');

        // Event listeners
        imageUpload.addEventListener('change', handleImageUpload);
        svgUpload.addEventListener('change', handleSvgUpload);
        imageContainer.addEventListener('click', handleImageClick);
        svgContainer.addEventListener('click', handleSvgClick);
        applyTransformation.addEventListener('click', applyTransformationHandler);
        clearOverlay.addEventListener('click', clearOverlayHandler);
        clearImagePoints.addEventListener('click', () => clearPoints('image'));
        clearSvgPoints.addEventListener('click', () => clearPoints('svg'));
        resetAll.addEventListener('click', resetAllHandler);
        affineTransform.addEventListener('change', () => updateTransformType('affine'));
        perspectiveTransform.addEventListener('change', () => updateTransformType('perspective'));

        // File upload handlers
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    uploadedImage.src = event.target.result;
                    uploadedImage.style.display = 'block';
                    document.getElementById('imagePlaceholder').style.display = 'none';
                    state.image = uploadedImage;
                    updateOverlay();
                };
                reader.readAsDataURL(file);
            }
        }

        function handleSvgUpload(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const svgContent = event.target.result;
                    uploadedSvg.innerHTML = svgContent;
                    uploadedSvg.style.display = 'block';
                    document.getElementById('svgPlaceholder').style.display = 'none';
                    state.svg = uploadedSvg;
                    updateOverlay();
                };
                reader.readAsText(file);
            }
        }

        // Point selection handlers
        function handleImageClick(e) {
            if (!state.isSelectingPoints || state.imagePoints.length >= 4) return;
            
            const rect = imageContainer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            state.imagePoints.push({ x, y });
            imagePointsCount.textContent = state.imagePoints.length;
            
            addPointMarker(imageContainer, x, y, '#3b82f6');
            updateApplyButton();
        }

        function handleSvgClick(e) {
            if (!state.isSelectingPoints || state.svgPoints.length >= 4) return;
            
            const rect = svgContainer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            state.svgPoints.push({ x, y });
            svgPointsCount.textContent = state.svgPoints.length;
            
            addPointMarker(svgContainer, x, y, '#10b981');
            updateApplyButton();
        }

        // Add point marker
        function addPointMarker(container, x, y, color) {
            const marker = document.createElement('div');
            marker.className = 'point-marker';
            marker.style.left = `${x}px`;
            marker.style.top = `${y}px`;
            marker.style.backgroundColor = color;
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '12');
            svg.setAttribute('height', '12');
            svg.setAttribute('viewBox', '0 0 12 12');
            
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', '6');
            circle.setAttribute('cy', '6');
            circle.setAttribute('r', '5');
            circle.setAttribute('fill', color);
            circle.setAttribute('stroke', 'white');
            circle.setAttribute('stroke-width', '1');
            
            svg.appendChild(circle);
            marker.appendChild(svg);
            container.appendChild(marker);
        }

        // Clear points
        function clearPoints(type) {
            if (type === 'image') {
                state.imagePoints = [];
                imagePointsCount.textContent = '0';
                const markers = imageContainer.querySelectorAll('.point-marker');
                markers.forEach(marker => marker.remove());
            } else if (type === 'svg') {
                state.svgPoints = [];
                svgPointsCount.textContent = '0';
                const markers = svgContainer.querySelectorAll('.point-marker');
                markers.forEach(marker => marker.remove());
            }
            updateApplyButton();
        }

        // Update apply button state
        function updateApplyButton() {
            const minPoints = state.transformType === 'affine' ? 3 : 4;
            applyTransformation.disabled = state.imagePoints.length < minPoints || state.svgPoints.length < minPoints;
        }

        // Update transform type
        function updateTransformType(type) {
            state.transformType = type;
            updateApplyButton();
        }

        // Update overlay
        function updateOverlay() {
            if (state.image && state.svg) {
                document.getElementById('overlayPlaceholder').style.display = 'none';
                document.getElementById('overlayContent').style.display = 'block';
                overlayImage.src = state.image.src;
                
                // Clone SVG for overlay
                overlaySvgContainer.innerHTML = '';
                const clonedSvg = state.svg.cloneNode(true);
                clonedSvg.style.position = 'absolute';
                clonedSvg.style.top = '0';
                clonedSvg.style.left = '0';
                clonedSvg.style.width = '100%';
                clonedSvg.style.height = '100%';
                overlaySvgContainer.appendChild(clonedSvg);
                
                // Add point markers to overlay
                state.svgPoints.forEach((point, index) => {
                    const marker = addPointMarker(overlaySvgContainer, point.x, point.y, '#10b981');
                    marker.style.pointerEvents = 'none';
                });
            }
        }

        // Apply transformation
        function applyTransformationHandler() {
            const minPoints = state.transformType === 'affine' ? 3 : 4;
            
            if (state.imagePoints.length < minPoints || state.svgPoints.length < minPoints) {
                return;
            }
            
            // Calculate transformation matrix
            let transformMatrix;
            if (state.transformType === 'affine') {
                transformMatrix = calculateAffineTransform(state.imagePoints, state.svgPoints);
            } else {
                transformMatrix = calculatePerspectiveTransform(state.imagePoints, state.svgPoints);
            }
            
            // Apply transformation to SVG in overlay
            if (transformMatrix && overlaySvgContainer.firstChild) {
                const svg = overlaySvgContainer.firstChild;
                
                if (state.transformType === 'affine') {
                    // Apply affine transformation
                    const a = transformMatrix[0];
                    const b = transformMatrix[1];
                    const c = transformMatrix[2];
                    const d = transformMatrix[3];
                    const e = transformMatrix[4];
                    const f = transformMatrix[5];
                    
                    svg.style.transform = `matrix(${a}, ${b}, ${c}, ${d}, ${e}, ${f})`;
                } else {
                    // For perspective transform, we need to apply CSS transform with perspective
                    // This is an approximation as full perspective transform requires more complex handling
                    const a = transformMatrix[0];
                    const b = transformMatrix[1];
                    const c = transformMatrix[2];
                    const d = transformMatrix[3];
                    const e = transformMatrix[4];
                    const f = transformMatrix[5];
                    const g = transformMatrix[6];
                    const h = transformMatrix[7];
                    const i = transformMatrix[8];
                    
                    // Normalize the matrix
                    const normalizedMatrix = [
                        a/i, b/i, c/i,
                        d/i, e/i, f/i,
                        0, 0, 1
                    ];
                    
                    // Apply as affine approximation
                    svg.style.transform = `matrix(${normalizedMatrix[0]}, ${normalizedMatrix[3]}, ${normalizedMatrix[1]}, ${normalizedMatrix[4]}, ${normalizedMatrix[2]}, ${normalizedMatrix[5]})`;
                }
                
                // Update point markers
                overlaySvgContainer.innerHTML = '';
                const clonedSvg = state.svg.cloneNode(true);
                clonedSvg.style.position = 'absolute';
                clonedSvg.style.top = '0';
                clonedSvg.style.left = '0';
                clonedSvg.style.width = '100%';
                clonedSvg.style.height = '100%';
                
                // Apply the same transformation to markers
                if (state.transformType === 'affine') {
                    clonedSvg.style.transform = `matrix(${a}, ${b}, ${c}, ${d}, ${e}, ${f})`;
                } else {
                    clonedSvg.style.transform = `matrix(${normalizedMatrix[0]}, ${normalizedMatrix[3]}, ${normalizedMatrix[1]}, ${normalizedMatrix[4]}, ${normalizedMatrix[2]}, ${normalizedMatrix[5]})`;
                }
                
                overlaySvgContainer.appendChild(clonedSvg);
                
                // Add transformed point markers
                state.svgPoints.forEach((point, index) => {
                    const transformedPoint = applyTransformToPoint(point, transformMatrix);
                    if (transformedPoint) {
                        addPointMarker(overlaySvgContainer, transformedPoint.x, transformedPoint.y, '#10b981');
                    }
                });
            }
        }

        // Calculate affine transformation matrix
        function calculateAffineTransform(sourcePoints, targetPoints) {
            if (sourcePoints.length < 3 || targetPoints.length < 3) return null;
            
            // Use the first 3 points
            const p1 = sourcePoints[0];
            const p2 = sourcePoints[1];
            const p3 = sourcePoints[2];
            
            const q1 = targetPoints[0];
            const q2 = targetPoints[1];
            const q3 = targetPoints[2];
            
            // Calculate transformation matrix
            const a = (q2.x - q1.x) * (p3.y - p1.y) - (q3.x - q1.x) * (p2.y - p1.y);
            const b = (q2.y - q1.y) * (p3.y - p1.y) - (q3.y - q1.y) * (p2.y - p1.y);
            const c = (q2.x - q1.x) * (p3.x - p1.x) - (q3.x - q1.x) * (p2.x - p1.x);
            const d = (q2.y - q1.y) * (p3.x - p1.x) - (q3.y - q1.y) * (p2.x - p1.x);
            
            const e = q1.x - p1.x * a - p1.y * c;
            const f = q1.y - p1.x * b - p1.y * d;
            
            return [a, b, c, d, e, f];
        }

        // Calculate perspective transformation matrix
        function calculatePerspectiveTransform(sourcePoints, targetPoints) {
            if (sourcePoints.length < 4 || targetPoints.length < 4) return null;
            
            // Use the first 4 points
            const p1 = sourcePoints[0];
            const p2 = sourcePoints[1];
            const p3 = sourcePoints[2];
            const p4 = sourcePoints[3];
            
            const q1 = targetPoints[0];
            const q2 = targetPoints[1];
            const q3 = targetPoints[2];
            const q4 = targetPoints[3];
            
            // Solve for homography matrix
            // This is a simplified implementation - a full solution would use more robust methods
            const x1 = p1.x, y1 = p1.y;
            const x2 = p2.x, y2 = p2.y;
            const x3 = p3.x, y3 = p3.y;
            const x4 = p4.x, y4 = p4.y;
            
            const xp1 = q1.x, yp1 = q1.y;
            const xp2 = q2.x, yp2 = q2.y;
            const xp3 = q3.x, yp3 = q3.y;
            const xp4 = q4.x, yp4 = q4.y;
            
            // Calculate using DLT (Direct Linear Transform) method
            const A = [];
            
            // First equation
            A.push([x1, y1, 1, 0, 0, 0, -x1*xp1, -y1*xp1, -xp1]);
            // Second equation
            A.push([0, 0, 0, x1, y1, 1, -x1*yp1, -y1*yp1, -yp1]);
            // Third equation
            A.push([x2, y2, 1, 0, 0, 0, -x2*xp2, -y2*xp2, -xp2]);
            // Fourth equation
            A.push([0, 0, 0, x2, y2, 1, -x2*yp2, -y2*yp2, -yp2]);
            // Fifth equation
            A.push([x3, y3, 1, 0, 0, 0, -x3*xp3, -y3*xp3, -xp3]);
            // Sixth equation
            A.push([0, 0, 0, x3, y3, 1, -x3*yp3, -y3*yp3, -yp3]);
            // Seventh equation
            A.push([x4, y4, 1, 0, 0, 0, -x4*xp4, -y4*xp4, -xp4]);
            // Eighth equation
            A.push([0, 0, 0, x4, y4, 1, -x4*yp4, -y4*yp4, -yp4]);
            
            // Solve the system of equations using SVD (Simplified)
            // This is a simplified version - a full implementation would use proper matrix algebra
            const H = [1, 0, 0, 0, 1, 0, 0, 0, 1];
            
            // This is a placeholder - in a real implementation, we'd use proper matrix solving
            // For the purpose of this demo, we'll return an approximation
            
            // Calculate average scaling factors
            const scaleX = (xp2 - xp1 + xp3 - xp4) / (x2 - x1 + x3 - x4);
            const scaleY = (yp2 - yp1 + yp3 - yp4) / (y2 - y1 + y3 - y4);
            
            // Calculate average translation
            const translateX = (xp1 + xp2 + xp3 + xp4) / 4 - (scaleX * (x1 + x2 + x3 + x4) / 4);
            const translateY = (yp1 + yp2 + yp3 + yp4) / 4 - (scaleY * (y1 + y2 + y3 + y4) / 4);
            
            // Calculate rotation (simplified)
            const angle = Math.atan2(yp2 - yp1, xp2 - xp1) - Math.atan2(y2 - y1, x2 - x1);
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            
            // Construct transformation matrix
            return [
                scaleX * cos, scaleY * sin, translateX,
                -scaleX * sin, scaleY * cos, translateY,
                0, 0, 1
            ];
        }

        // Apply transformation to a point
        function applyTransformToPoint(point, matrix) {
            if (!matrix) return null;
            
            if (matrix.length === 6) {
                // Affine transform
                const x = matrix[0] * point.x + matrix[2] * point.y + matrix[4];
                const y = matrix[1] * point.x + matrix[3] * point.y + matrix[5];
                return { x, y };
            } else if (matrix.length === 9) {
                // Perspective transform
                const x = matrix[0] * point.x + matrix[1] * point.y + matrix[2];
                const y = matrix[3] * point.x + matrix[4] * point.y + matrix[5];
                const w = matrix[6] * point.x + matrix[7] * point.y + matrix[8];
                return { x: x/w, y: y/w };
            }
            
            return null;
        }

        // Clear overlay
        function clearOverlayHandler() {
            overlaySvgContainer.innerHTML = '';
            overlayImage.src = '';
            document.getElementById('overlayPlaceholder').style.display = 'flex';
            document.getElementById('overlayContent').style.display = 'none';
            state.image = null;
            state.svg = null;
            uploadedImage.style.display = 'none';
            uploadedSvg.style.display = 'none';
            document.getElementById('imagePlaceholder').style.display = 'flex';
            document.getElementById('svgPlaceholder').style.display = 'flex';
            
            // Clear points
            clearPoints('image');
            clearPoints('svg');
            updateApplyButton();
        }

        // Reset all
        function resetAllHandler() {
            // Clear all points
            clearPoints('image');
            clearPoints('svg');
            
            // Clear files
            imageUpload.value = '';
            svgUpload.value = '';
            
            // Clear overlay
            clearOverlayHandler();
            
            // Reset transform type
            affineTransform.checked = true;
            perspectiveTransform.checked = false;
            state.transformType = 'affine';
            updateApplyButton();
        }
    </script>
</body>
</html>