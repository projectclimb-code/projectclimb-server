<!-- added zoom option-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Image ↔ SVG Alignment (3 or 4 points) + Zoom/Pan</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --panel-gap: 12px;
    --dot-size: 10px;
    --dot-border: 2px;
  }
  * { box-sizing: border-box; }
  body { margin: 0; font-family: system-ui, Arial, sans-serif; }
  header, footer { padding: 12px; border-bottom: 1px solid #e5e5e5; }
  footer { border-top: 1px solid #e5e5e5; border-bottom: none; color: #666; font-size: 12px; }
  .controls { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
  .controls > * { margin: 4px 0; }
  .row { display: flex; gap: var(--panel-gap); padding: 12px; }
  .panel {
    flex: 1 1 0;
    min-width: 260px;
    border: 1px solid #ddd;
    border-radius: 8px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }
  .panel h3 {
    margin: 0;
    padding: 8px 10px;
    background: #f8f8f8;
    border-bottom: 1px solid #eee;
    font-size: 14px;
  }
  .stage {
    position: relative;
    display: grid;
    place-items: center;
    background: #fafafa;
    min-height: 300px;
    touch-action: none; /* allow us to prevent browser gestures over the canvas */
  }
  .stage-inner {
    position: relative;
    width: 100%;
    max-width: 100%;
  }
  .zoom-wrap {
    position: relative;
    transform-origin: 0 0;
    width: 100%;
  }
  .zoom-wrap img {
    display: block;
    width: 100%;
    height: auto;
    user-select: none;
    -webkit-user-drag: none;
    pointer-events: none; /* clicks go to click-layer */
  }
  .overlay-stack {
    position: relative;
    width: 100%;
  }
  .overlay-stack img.bg {
    position: relative;
    z-index: 1;
  }
  .overlay-stack img.svg-overlay {
    position: absolute;
    left: 0; top: 0;
    z-index: 2;
    transform-origin: 0 0;
    opacity: 0.75;
    will-change: transform;
  }
  .click-layer {
    position: absolute;
    inset: 0;
    z-index: 5;
    cursor: crosshair;
  }
  .click-layer.panning {
    cursor: grabbing;
  }
  .dots {
    position: absolute;
    inset: 0;
    z-index: 6;
    pointer-events: none;
  }
  .dot {
    position: absolute;
    width: var(--dot-size);
    height: var(--dot-size);
    border: var(--dot-border) solid #fff;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 0 0 1px rgba(0,0,0,0.45);
    display: grid;
    place-items: center;
    font-size: 9px;
    font-weight: 600;
    color: #fff;
    line-height: 1;
  }
  .dot-label {
    position: absolute;
    top: -16px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.6);
    color: #fff;
    font-size: 10px;
    padding: 1px 4px;
    border-radius: 3px;
    white-space: nowrap;
  }
  .dot.img { background: #1a73e8; }
  .dot.svg { background: #e91e63; }
  .legend { padding: 8px 10px; font-size: 12px; color: #666; border-top: 1px solid #eee; background: #fcfcfc; }
  .btn { padding: 6px 10px; border: 1px solid #ccc; background: #fff; border-radius: 6px; cursor: pointer; }
  .btn:disabled { opacity: 0.5; cursor: default; }
  .sep { width: 1px; height: 20px; background: #ddd; margin: 0 6px; }
  .slider { vertical-align: middle; }
  .warning { color: #b45309; }
  .success { color: #2e7d32; }
  .error { color: #c62828; }
  .zoom-controls { display: inline-flex; gap: 4px; align-items: center; }
  .zoom-label { font-size: 12px; color: #555; min-width: 52px; text-align: right; }
</style>
</head>
<body>
  <header>
    <div class="controls">
      <label>Image: <input id="imageFile" type="file" accept="image/*" /></label>
      <label>SVG: <input id="svgFile" type="file" accept=".svg,image/svg+xml" /></label>

      <span class="sep"></span>

      <button class="btn" id="clearImgPts">Clear image points</button>
      <button class="btn" id="clearSvgPts">Clear SVG points</button>
      <button class="btn" id="undoImgPt">Undo image point</button>
      <button class="btn" id="undoSvgPt">Undo SVG point</button>

      <span class="sep"></span>

      <button class="btn" id="fitBtn" disabled>Fit (3 or 4 pairs)</button>
      <label title="Force affine even with 4 points (least-squares)">
        <input id="forceAffine" type="checkbox" />
        Force affine
      </label>

      <span class="sep"></span>

      <label>Overlay opacity
        <input id="opacity" class="slider" type="range" min="0" max="1" step="0.02" value="0.75" />
      </label>
      <button class="btn" id="resetTransform">Reset transform</button>

      <span class="sep"></span>

      <div class="zoom-controls">
        <strong>Image zoom:</strong>
        <button class="btn" id="imgZoomOut">−</button>
        <button class="btn" id="imgZoomIn">+</button>
        <button class="btn" id="imgZoomReset">Reset</button>
        <span class="zoom-label" id="imgZoomLabel">100%</span>
      </div>

      <div class="zoom-controls">
        <strong>SVG zoom:</strong>
        <button class="btn" id="svgZoomOut">−</button>
        <button class="btn" id="svgZoomIn">+</button>
        <button class="btn" id="svgZoomReset">Reset</button>
        <span class="zoom-label" id="svgZoomLabel">100%</span>
      </div>
    </div>
  </header>

  <div class="row">
    <div class="panel" id="panelImage">
      <h3>Image (click 3–4 points)</h3>
      <div class="stage">
        <div class="stage-inner" id="imageStage">
          <div class="zoom-wrap" id="imgZoomWrap">
            <img id="imgLeft" alt="image" />
            <div class="dots" id="imgDots"></div>
          </div>
          <div class="click-layer" id="imgClick" title="Click to add points. Hold Space and drag to pan. Ctrl/Cmd+Wheel to zoom."></div>
        </div>
      </div>
      <div class="legend">
        Blue dots = image points. Hold Space and drag to pan. Ctrl/Cmd + Wheel to zoom.
      </div>
    </div>

    <div class="panel" id="panelSVG">
      <h3>SVG (click matching 3–4 points)</h3>
      <div class="stage">
        <div class="stage-inner" id="svgStage">
          <div class="zoom-wrap" id="svgZoomWrap">
            <img id="svgMiddle" alt="svg" />
            <div class="dots" id="svgDots"></div>
          </div>
          <div class="click-layer" id="svgClick" title="Click to add points. Hold Space and drag to pan. Ctrl/Cmd+Wheel to zoom."></div>
        </div>
      </div>
      <div class="legend">
        Pink dots = SVG points. Hold Space and drag to pan. Ctrl/Cmd + Wheel to zoom.
      </div>
    </div>

    <div class="panel" id="panelOverlay">
      <h3>Overlay: SVG on Image</h3>
      <div class="stage">
        <div class="stage-inner overlay-stack" id="overlayStage">
          <img id="imgOverlay" class="bg" alt="image overlay background" />
          <img id="svgOverlay" class="svg-overlay" alt="svg overlay" />
        </div>
      </div>
      <div class="legend">
        Use the Fit button after picking corresponding points.
      </div>
    </div>
  </div>

  <footer>
    Tips:
    - Click in Image and SVG panels to add corresponding points in the same order.
    - 3 points => affine transform. 4 points => homography (unless “Force affine” is on).
    - Use Ctrl/Cmd+Wheel or the +/- buttons to zoom. Hold Space and drag to pan.
    - Avoid resizing the window between picking points and fitting, to keep coordinates consistent.
  </footer>

<script>
  // State
  const state = {
    imgURL: null,
    svgURL: null,
    imgPts: [], // [{x,y}] in content (pre-zoom) coordinates
    svgPts: [], // [{x,y}] in content (pre-zoom) coordinates
    lastApplied: null, // 'affine' | 'homography' | null
    zoom: {
      img: { scale: 1, tx: 0, ty: 0 },
      svg: { scale: 1, tx: 0, ty: 0 }
    },
    panning: {
      img: { active: false, lastX: 0, lastY: 0, moved: false },
      svg: { active: false, lastX: 0, lastY: 0, moved: false }
    },
    spaceDown: false
  };

  const els = {
    imageFile: document.getElementById('imageFile'),
    svgFile: document.getElementById('svgFile'),
    imgLeft: document.getElementById('imgLeft'),
    svgMiddle: document.getElementById('svgMiddle'),
    imgOverlay: document.getElementById('imgOverlay'),
    svgOverlay: document.getElementById('svgOverlay'),
    imgClick: document.getElementById('imgClick'),
    svgClick: document.getElementById('svgClick'),
    imgDots: document.getElementById('imgDots'),
    svgDots: document.getElementById('svgDots'),
    fitBtn: document.getElementById('fitBtn'),
    clearImgPts: document.getElementById('clearImgPts'),
    clearSvgPts: document.getElementById('clearSvgPts'),
    undoImgPt: document.getElementById('undoImgPt'),
    undoSvgPt: document.getElementById('undoSvgPt'),
    forceAffine: document.getElementById('forceAffine'),
    opacity: document.getElementById('opacity'),
    resetTransform: document.getElementById('resetTransform'),
    overlayStage: document.getElementById('overlayStage'),
    imageStage: document.getElementById('imageStage'),
    svgStage: document.getElementById('svgStage'),
    imgZoomWrap: document.getElementById('imgZoomWrap'),
    svgZoomWrap: document.getElementById('svgZoomWrap'),
    imgZoomIn: document.getElementById('imgZoomIn'),
    imgZoomOut: document.getElementById('imgZoomOut'),
    imgZoomReset: document.getElementById('imgZoomReset'),
    svgZoomIn: document.getElementById('svgZoomIn'),
    svgZoomOut: document.getElementById('svgZoomOut'),
    svgZoomReset: document.getElementById('svgZoomReset'),
    imgZoomLabel: document.getElementById('imgZoomLabel'),
    svgZoomLabel: document.getElementById('svgZoomLabel')
  };

  // File loading
  els.imageFile.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    if (state.imgURL) URL.revokeObjectURL(state.imgURL);
    state.imgURL = URL.createObjectURL(file);
    els.imgLeft.src = state.imgURL;
    els.imgOverlay.src = state.imgURL;
    clearPoints('img');
    resetOverlayTransform();
    resetZoom('img');
  });

  els.svgFile.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    const svgText = await file.text();
    const svgBlob = new Blob([svgText], {type: 'image/svg+xml'});
    if (state.svgURL) URL.revokeObjectURL(state.svgURL);
    state.svgURL = URL.createObjectURL(svgBlob);
    els.svgMiddle.src = state.svgURL;
    els.svgOverlay.src = state.svgURL;
    clearPoints('svg');
    resetOverlayTransform();
    resetZoom('svg');
  });

  // Click capture helper (relative to a container)
  function relativeXY(evt, container) {
    const r = container.getBoundingClientRect();
    const x = evt.clientX - r.left;
    const y = evt.clientY - r.top;
    return { x, y };
  }

  // Zoom helpers
  const MIN_SCALE = 0.25;
  const MAX_SCALE = 16;

  function applyZoom(which) {
    const z = state.zoom[which];
    const wrap = which === 'img' ? els.imgZoomWrap : els.svgZoomWrap;
    wrap.style.transform = `translate(${z.tx}px, ${z.ty}px) scale(${z.scale})`;
    const label = which === 'img' ? els.imgZoomLabel : els.svgZoomLabel;
    label.textContent = Math.round(z.scale * 100) + '%';
  }

  function resetZoom(which) {
    state.zoom[which] = { scale: 1, tx: 0, ty: 0 };
    applyZoom(which);
  }

  function clampScale(s) {
    return Math.min(MAX_SCALE, Math.max(MIN_SCALE, s));
  }

  function zoomAt(which, factor, cx, cy, container) {
    const z = state.zoom[which];
    const oldScale = z.scale;
    const newScale = clampScale(oldScale * factor);
    const f = newScale / oldScale;
    // Keep point under cursor fixed: t' = p - s' * ((p - t)/s)
    const p = { x: cx, y: cy };
    const contentX = (p.x - z.tx) / oldScale;
    const contentY = (p.y - z.ty) / oldScale;
    z.scale = newScale;
    z.tx = p.x - newScale * contentX;
    z.ty = p.y - newScale * contentY;
    applyZoom(which);
  }

  function screenToContent(which, pt) {
    const z = state.zoom[which];
    return {
      x: (pt.x - z.tx) / z.scale,
      y: (pt.y - z.ty) / z.scale
    };
  }

  // Marker management
  function renderDots(which) {
    const dotsLayer = which === 'img' ? els.imgDots : els.svgDots;
    dotsLayer.innerHTML = '';
    const pts = which === 'img' ? state.imgPts : state.svgPts;
    pts.forEach((p, i) => {
      const dot = document.createElement('div');
      dot.className = 'dot ' + (which === 'img' ? 'img' : 'svg');
      dot.style.left = p.x + 'px';
      dot.style.top = p.y + 'px';
      const label = document.createElement('div');
      label.className = 'dot-label';
      label.textContent = String(i + 1);
      dot.appendChild(label);
      dotsLayer.appendChild(dot);
    });
    updateFitButton();
  }

  function clearPoints(which) {
    if (which === 'img' || which === 'both') {
      state.imgPts = [];
      renderDots('img');
    }
    if (which === 'svg' || which === 'both') {
      state.svgPts = [];
      renderDots('svg');
    }
  }

  function undoPoint(which) {
    if (which === 'img') {
      state.imgPts.pop();
      renderDots('img');
    } else {
      state.svgPts.pop();
      renderDots('svg');
    }
  }

  // Enable fit button only when counts match and are 3 or 4
  function updateFitButton() {
    const n = state.imgPts.length;
    const m = state.svgPts.length;
    const ok = (n === m) && (n === 3 || n === 4);
    els.fitBtn.disabled = !ok || !state.imgURL || !state.svgURL;
  }

  // Pan/zoom interactions per panel
  function setupPanZoom(which, stageEl, clickLayer) {
    // Wheel zoom (Ctrl/Cmd+wheel to avoid hijacking normal page scroll)
    stageEl.addEventListener('wheel', (e) => {
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        const p = relativeXY(e, stageEl);
        const factor = Math.pow(1.0015, -e.deltaY); // smooth zoom
        zoomAt(which, factor, p.x, p.y, stageEl);
      }
    }, { passive: false });

    // Buttons
    const zoomInBtn = which === 'img' ? els.imgZoomIn : els.svgZoomIn;
    const zoomOutBtn = which === 'img' ? els.imgZoomOut : els.svgZoomOut;
    const zoomResetBtn = which === 'img' ? els.imgZoomReset : els.svgZoomReset;

    zoomInBtn.addEventListener('click', () => {
      const rect = stageEl.getBoundingClientRect();
      zoomAt(which, 1.25, rect.width / 2, rect.height / 2, stageEl);
    });
    zoomOutBtn.addEventListener('click', () => {
      const rect = stageEl.getBoundingClientRect();
      zoomAt(which, 1 / 1.25, rect.width / 2, rect.height / 2, stageEl);
    });
    zoomResetBtn.addEventListener('click', () => resetZoom(which));

    // Panning (Space+drag or middle/right mouse)
    clickLayer.addEventListener('mousedown', (e) => {
      const isPanButton = e.button === 1 || e.button === 2; // middle/right
      if (state.spaceDown || isPanButton) {
        e.preventDefault();
        const pan = state.panning[which];
        pan.active = true;
        pan.moved = false;
        pan.lastX = e.clientX;
        pan.lastY = e.clientY;
        clickLayer.classList.add('panning');
      }
    });
    window.addEventListener('mousemove', (e) => {
      const pan = state.panning[which];
      if (!pan.active) return;
      e.preventDefault();
      const dx = e.clientX - pan.lastX;
      const dy = e.clientY - pan.lastY;
      pan.lastX = e.clientX;
      pan.lastY = e.clientY;
      pan.moved = pan.moved || Math.abs(dx) + Math.abs(dy) > 1;
      const z = state.zoom[which];
      z.tx += dx;
      z.ty += dy;
      applyZoom(which);
    });
    window.addEventListener('mouseup', () => {
      const pan = state.panning[which];
      if (pan.active) {
        pan.active = false;
        clickLayer.classList.remove('panning');
      }
    });

    // Add points on click if not panning
    clickLayer.addEventListener('click', (e) => {
      const pan = state.panning[which];
      if (pan.moved) {
        // End of a pan gesture; do not add a point
        pan.moved = false;
        return;
      }
      if (e.button !== 0) return; // only left click adds points
      // Convert to content coords
      const p = relativeXY(e, stageEl);
      const c = screenToContent(which, p);
      if (which === 'img') {
        state.imgPts.push(c);
        renderDots('img');
      } else {
        state.svgPts.push(c);
        renderDots('svg');
      }
    });

    // Context menu suppression on right-drag pan
    clickLayer.addEventListener('contextmenu', (e) => {
      if (state.panning[which].active) e.preventDefault();
    });
  }

  // Global spacebar tracking for pan gesture
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
      state.spaceDown = true;
      // Update cursor style
      els.imgClick.classList.add('panning');
      els.svgClick.classList.add('panning');
    }
  });
  window.addEventListener('keyup', (e) => {
    if (e.code === 'Space') {
      state.spaceDown = false;
      if (!state.panning.img.active) els.imgClick.classList.remove('panning');
      if (!state.panning.svg.active) els.svgClick.classList.remove('panning');
    }
  });

  setupPanZoom('img', els.imageStage, els.imgClick);
  setupPanZoom('svg', els.svgStage, els.svgClick);

  // Buttons
  els.clearImgPts.addEventListener('click', () => clearPoints('img'));
  els.clearSvgPts.addEventListener('click', () => clearPoints('svg'));
  els.undoImgPt.addEventListener('click', () => undoPoint('img'));
  els.undoSvgPt.addEventListener('click', () => undoPoint('svg'));
  els.opacity.addEventListener('input', () => {
    els.svgOverlay.style.opacity = els.opacity.value;
  });
  els.resetTransform.addEventListener('click', resetOverlayTransform);

  function resetOverlayTransform() {
    els.svgOverlay.style.transform = 'none';
    els.svgOverlay.style.transformOrigin = '0 0';
    els.svgOverlay.style.opacity = els.opacity.value;
    state.lastApplied = null;
  }

  // Linear algebra helpers
  function solveLinear(A, b) {
    const n = A.length;
    for (let i = 0; i < n; i++) {
      A[i] = A[i].slice();
      A[i].push(b[i]);
    }
    for (let i = 0; i < n; i++) {
      let maxRow = i;
      for (let r = i + 1; r < n; r++) {
        if (Math.abs(A[r][i]) > Math.abs(A[maxRow][i])) maxRow = r;
      }
      if (Math.abs(A[maxRow][i]) < 1e-12) throw new Error('Singular matrix');
      if (maxRow !== i) {
        const tmp = A[i]; A[i] = A[maxRow]; A[maxRow] = tmp;
      }
      const pivot = A[i][i];
      for (let c = i; c <= n; c++) A[i][c] /= pivot;
      for (let r = 0; r < n; r++) {
        if (r === i) continue;
        const f = A[r][i];
        if (Math.abs(f) < 1e-20) continue;
        for (let c = i; c <= n; c++) A[r][c] -= f * A[i][c];
      }
    }
    const x = new Array(n);
    for (let i = 0; i < n; i++) x[i] = A[i][n];
    return x;
  }

  function computeAffine(srcPts, dstPts) {
    const n = srcPts.length;
    if (n < 3) throw new Error('Need at least 3 points for affine');
    const rows = 2 * n;
    const M = Array.from({length: rows}, () => Array(6).fill(0));
    const b = new Array(rows);

    for (let i = 0; i < n; i++) {
      const {x, y} = srcPts[i];
      const {x: X, y: Y} = dstPts[i];
      const r = 2 * i;
      M[r][0] = x; M[r][1] = y; M[r][2] = 1; M[r][3] = 0; M[r][4] = 0; M[r][5] = 0;
      b[r] = X;
      M[r+1][0] = 0; M[r+1][1] = 0; M[r+1][2] = 0; M[r+1][3] = x; M[r+1][4] = y; M[r+1][5] = 1;
      b[r+1] = Y;
    }

    const MTM = Array.from({length: 6}, () => Array(6).fill(0));
    const MTb = new Array(6).fill(0);
    for (let r = 0; r < rows; r++) {
      for (let i = 0; i < 6; i++) {
        MTb[i] += M[r][i] * b[r];
        for (let j = 0; j < 6; j++) {
          MTM[i][j] += M[r][i] * M[r][j];
        }
      }
    }

    const p = solveLinear(MTM, MTb);
    const a = p[0], c = p[1], e = p[2], b_ = p[3], d = p[4], f = p[5];
    return { a, b: b_, c, d, e, f };
  }

  function computeHomography4(srcPts, dstPts) {
    if (srcPts.length !== 4) throw new Error('Need 4 points for homography');
    const A = [], b = [];
    for (let i = 0; i < 4; i++) {
      const x = srcPts[i].x, y = srcPts[i].y;
      const X = dstPts[i].x, Y = dstPts[i].y;
      A.push([x, y, 1, 0, 0, 0, -x*X, -y*X]);
      b.push(X);
      A.push([0, 0, 0, x, y, 1, -x*Y, -y*Y]);
      b.push(Y);
    }
    const h = solveLinear(A, b);
    const H = [
      [h[0], h[1], h[2]],
      [h[3], h[4], h[5]],
      [h[6], h[7], 1   ]
    ];
    return H;
  }

  function applyAffineToOverlay({a, b, c, d, e, f}) {
    els.svgOverlay.style.transform = `matrix(${a}, ${b}, ${c}, ${d}, ${e}, ${f})`;
    els.svgOverlay.style.transformOrigin = '0 0';
    state.lastApplied = 'affine';
  }

  function applyHomographyToOverlay(H) {
    const h11 = H[0][0], h12 = H[0][1], h13 = H[0][2];
    const h21 = H[1][0], h22 = H[1][1], h23 = H[1][2];
    const h31 = H[2][0], h32 = H[2][1];
    const css = [
      h11, h21, 0,   h31,
      h12, h22, 0,   h32,
      0,   0,   1,   0,
      h13, h23, 0,   1
    ];
    els.svgOverlay.style.transform = `matrix3d(${css.map(n => Number.isFinite(n) ? n : 0).join(',')})`;
    els.svgOverlay.style.transformOrigin = '0 0';
    state.lastApplied = 'homography';
  }

  // Fit button logic
  els.fitBtn.addEventListener('click', () => {
    const n = state.imgPts.length;
    if (n !== state.svgPts.length || (n !== 3 && n !== 4)) return;

    try {
      if (n === 3 || (n === 4 && els.forceAffine.checked)) {
        const aff = computeAffine(state.svgPts, state.imgPts);
        applyAffineToOverlay(aff);
      } else if (n === 4) {
        const H = computeHomography4(state.svgPts, state.imgPts);
        applyHomographyToOverlay(H);
      }
    } catch (err) {
      console.error(err);
      alert('Fit failed: ' + (err?.message || err));
    }
  });

  // Init
  els.svgOverlay.style.opacity = els.opacity.value;

  function maybeEnableFitWhenLoaded() {
    const ready = els.imgLeft.complete && els.svgMiddle.complete;
    updateFitButton();
  }
  els.imgLeft.addEventListener('load', () => {
    maybeEnableFitWhenLoaded();
    // Ensure zoom wraps are reset for correct size
    resetZoom('img');
  });
  els.svgMiddle.addEventListener('load', () => {
    maybeEnableFitWhenLoaded();
    resetZoom('svg');
  });

  // Keyboard zoom shortcuts (optional): + and - when focused on page
  window.addEventListener('keydown', (e) => {
    const activePanel = document.activeElement; // not strictly panel; just use center
    if ((e.key === '+' || e.key === '=') && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      const rect = els.imageStage.getBoundingClientRect();
      zoomAt('img', 1.25, rect.width/2, rect.height/2, els.imageStage);
    }
    if ((e.key === '-' || e.key === '_') && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      const rect = els.imageStage.getBoundingClientRect();
      zoomAt('img', 1/1.25, rect.width/2, rect.height/2, els.imageStage);
    }
  });
</script>
</body>
</html>