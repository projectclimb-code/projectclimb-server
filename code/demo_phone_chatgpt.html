<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Image ↔ SVG Alignment (3 or 4 points)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --panel-gap: 12px;
    --dot-size: 10px;
    --dot-border: 2px;
  }
  * { box-sizing: border-box; }
  body { margin: 0; font-family: system-ui, Arial, sans-serif; }
  header, footer { padding: 12px; border-bottom: 1px solid #e5e5e5; }
  footer { border-top: 1px solid #e5e5e5; border-bottom: none; color: #666; font-size: 12px; }
  .controls { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
  .controls > * { margin: 4px 0; }
  .row { display: flex; gap: var(--panel-gap); padding: 12px; }
  .panel {
    flex: 1 1 0;
    min-width: 260px;
    border: 1px solid #ddd;
    border-radius: 8px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }
  .panel h3 {
    margin: 0;
    padding: 8px 10px;
    background: #f8f8f8;
    border-bottom: 1px solid #eee;
    font-size: 14px;
  }
  .stage {
    position: relative;
    display: grid;
    place-items: center;
    background: #fafafa;
    min-height: 300px;
  }
  .stage-inner {
    position: relative;
    width: 100%;
    /* This keeps images/figures responsive and consistent across panels */
    max-width: 100%;
  }
  .stage-inner img {
    display: block;
    width: 100%;
    height: auto;
    user-select: none;
    -webkit-user-drag: none;
    pointer-events: auto;
  }
  .overlay-stack {
    position: relative;
    width: 100%;
  }
  .overlay-stack img.bg {
    position: relative;
    z-index: 1;
  }
  .overlay-stack img.svg-overlay {
    position: absolute;
    left: 0; top: 0;
    z-index: 2;
    transform-origin: 0 0;
    opacity: 0.75;
    will-change: transform;
  }
  .click-layer {
    position: absolute;
    inset: 0;
    z-index: 5;
    cursor: crosshair;
  }
  .dots {
    position: absolute;
    inset: 0;
    z-index: 6;
    pointer-events: none;
  }
  .dot {
    position: absolute;
    width: var(--dot-size);
    height: var(--dot-size);
    border: var(--dot-border) solid #fff;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 0 0 1px rgba(0,0,0,0.45);
    display: grid;
    place-items: center;
    font-size: 9px;
    font-weight: 600;
    color: #fff;
    line-height: 1;
  }
  .dot img { display: none; }
  .dot-label {
    position: absolute;
    top: -16px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.6);
    color: #fff;
    font-size: 10px;
    padding: 1px 4px;
    border-radius: 3px;
    white-space: nowrap;
  }
  .dot.img { background: #1a73e8; }
  .dot.svg { background: #e91e63; }
  .legend { padding: 8px 10px; font-size: 12px; color: #666; border-top: 1px solid #eee; background: #fcfcfc; }
  .btn { padding: 6px 10px; border: 1px solid #ccc; background: #fff; border-radius: 6px; cursor: pointer; }
  .btn:disabled { opacity: 0.5; cursor: default; }
  .sep { width: 1px; height: 20px; background: #ddd; margin: 0 6px; }
  .slider { vertical-align: middle; }
  .warning { color: #b45309; }
  .success { color: #2e7d32; }
  .error { color: #c62828; }
  code { background: #f2f2f2; padding: 2px 4px; border-radius: 4px; }
</style>
</head>
<body>
  <header>
    <div class="controls">
      <label>Image: <input id="imageFile" type="file" accept="image/*" /></label>
      <label>SVG: <input id="svgFile" type="file" accept=".svg,image/svg+xml" /></label>

      <span class="sep"></span>

      <button class="btn" id="clearImgPts">Clear image points</button>
      <button class="btn" id="clearSvgPts">Clear SVG points</button>
      <button class="btn" id="undoImgPt">Undo image point</button>
      <button class="btn" id="undoSvgPt">Undo SVG point</button>

      <span class="sep"></span>

      <button class="btn" id="fitBtn" disabled>Fit (3 or 4 pairs)</button>
      <label title="Force affine even with 4 points (least-squares)">
        <input id="forceAffine" type="checkbox" />
        Force affine
      </label>

      <span class="sep"></span>

      <label>Overlay opacity
        <input id="opacity" class="slider" type="range" min="0" max="1" step="0.02" value="0.75" />
      </label>
      <button class="btn" id="resetTransform">Reset transform</button>
    </div>
  </header>

  <div class="row">
    <div class="panel" id="panelImage">
      <h3>Image (click 3–4 points)</h3>
      <div class="stage">
        <div class="stage-inner" id="imageStage">
          <img id="imgLeft" alt="image" />
          <div class="click-layer" id="imgClick"></div>
          <div class="dots" id="imgDots"></div>
        </div>
      </div>
      <div class="legend">
        Blue dots = image points
      </div>
    </div>

    <div class="panel" id="panelSVG">
      <h3>SVG (click matching 3–4 points)</h3>
      <div class="stage">
        <div class="stage-inner" id="svgStage">
          <img id="svgMiddle" alt="svg" />
          <div class="click-layer" id="svgClick"></div>
          <div class="dots" id="svgDots"></div>
        </div>
      </div>
      <div class="legend">
        Pink dots = SVG points
      </div>
    </div>

    <div class="panel" id="panelOverlay">
      <h3>Overlay: SVG on Image</h3>
      <div class="stage">
        <div class="stage-inner overlay-stack" id="overlayStage">
          <img id="imgOverlay" class="bg" alt="image overlay background" />
          <img id="svgOverlay" class="svg-overlay" alt="svg overlay" />
        </div>
      </div>
      <div class="legend">
        Use the Fit button after picking corresponding points.
      </div>
    </div>
  </div>

  <footer>
    Tips:
    - Click in Image and SVG panels to add corresponding points in the same order.
    - 3 points => affine transform. 4 points => homography (unless “Force affine” is on).
    - You can drag the opacity slider to inspect the alignment.
  </footer>

<script>
  // State
  const state = {
    imgURL: null,
    svgURL: null,
    imgPts: [], // [{x,y}]
    svgPts: [], // [{x,y}]
    lastApplied: null // 'affine' | 'homography' | null
  };

  const els = {
    imageFile: document.getElementById('imageFile'),
    svgFile: document.getElementById('svgFile'),
    imgLeft: document.getElementById('imgLeft'),
    svgMiddle: document.getElementById('svgMiddle'),
    imgOverlay: document.getElementById('imgOverlay'),
    svgOverlay: document.getElementById('svgOverlay'),
    imgClick: document.getElementById('imgClick'),
    svgClick: document.getElementById('svgClick'),
    imgDots: document.getElementById('imgDots'),
    svgDots: document.getElementById('svgDots'),
    fitBtn: document.getElementById('fitBtn'),
    clearImgPts: document.getElementById('clearImgPts'),
    clearSvgPts: document.getElementById('clearSvgPts'),
    undoImgPt: document.getElementById('undoImgPt'),
    undoSvgPt: document.getElementById('undoSvgPt'),
    forceAffine: document.getElementById('forceAffine'),
    opacity: document.getElementById('opacity'),
    resetTransform: document.getElementById('resetTransform'),
    overlayStage: document.getElementById('overlayStage'),
    imageStage: document.getElementById('imageStage'),
    svgStage: document.getElementById('svgStage')
  };

  // File loading
  els.imageFile.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    if (state.imgURL) URL.revokeObjectURL(state.imgURL);
    state.imgURL = URL.createObjectURL(file);
    els.imgLeft.src = state.imgURL;
    els.imgOverlay.src = state.imgURL;
    // Clear previous points if image changes
    clearPoints('img');
    // Reset transform when image changes
    resetOverlayTransform();
  });

  els.svgFile.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    // Read as text and re-encode to preserve XML with proper data URL
    const svgText = await file.text();
    const svgBlob = new Blob([svgText], {type: 'image/svg+xml'});
    if (state.svgURL) URL.revokeObjectURL(state.svgURL);
    state.svgURL = URL.createObjectURL(svgBlob);
    els.svgMiddle.src = state.svgURL;
    els.svgOverlay.src = state.svgURL;
    clearPoints('svg');
    resetOverlayTransform();
  });

  // Click capture helper
  function relativeXY(evt, container) {
    const r = container.getBoundingClientRect();
    const x = evt.clientX - r.left;
    const y = evt.clientY - r.top;
    return { x, y };
  }

  // Marker management
  function renderDots(which) {
    const dotsLayer = which === 'img' ? els.imgDots : els.svgDots;
    dotsLayer.innerHTML = '';
    const pts = which === 'img' ? state.imgPts : state.svgPts;
    pts.forEach((p, i) => {
      const dot = document.createElement('div');
      dot.className = 'dot ' + (which === 'img' ? 'img' : 'svg');
      dot.style.left = p.x + 'px';
      dot.style.top = p.y + 'px';
      const label = document.createElement('div');
      label.className = 'dot-label';
      label.textContent = String(i + 1);
      dot.appendChild(label);
      dotsLayer.appendChild(dot);
    });
    updateFitButton();
  }

  function clearPoints(which) {
    if (which === 'img' || which === 'both') {
      state.imgPts = [];
      renderDots('img');
    }
    if (which === 'svg' || which === 'both') {
      state.svgPts = [];
      renderDots('svg');
    }
  }

  function undoPoint(which) {
    if (which === 'img') {
      state.imgPts.pop();
      renderDots('img');
    } else {
      state.svgPts.pop();
      renderDots('svg');
    }
  }

  // Enable fit button only when counts match and are 3 or 4
  function updateFitButton() {
    const n = state.imgPts.length;
    const m = state.svgPts.length;
    const ok = (n === m) && (n === 3 || n === 4);
    els.fitBtn.disabled = !ok || !state.imgURL || !state.svgURL;
  }

  // Click listeners
  els.imgClick.addEventListener('click', (e) => {
    if (!els.imgLeft.complete) return;
    const p = relativeXY(e, els.imageStage);
    state.imgPts.push(p);
    renderDots('img');
  });

  els.svgClick.addEventListener('click', (e) => {
    if (!els.svgMiddle.complete) return;
    const p = relativeXY(e, els.svgStage);
    state.svgPts.push(p);
    renderDots('svg');
  });

  // Buttons
  els.clearImgPts.addEventListener('click', () => clearPoints('img'));
  els.clearSvgPts.addEventListener('click', () => clearPoints('svg'));
  els.undoImgPt.addEventListener('click', () => undoPoint('img'));
  els.undoSvgPt.addEventListener('click', () => undoPoint('svg'));
  els.opacity.addEventListener('input', () => {
    els.svgOverlay.style.opacity = els.opacity.value;
  });
  els.resetTransform.addEventListener('click', resetOverlayTransform);

  function resetOverlayTransform() {
    els.svgOverlay.style.transform = 'none';
    els.svgOverlay.style.transformOrigin = '0 0';
    els.svgOverlay.style.opacity = els.opacity.value;
    state.lastApplied = null;
  }

  // Linear algebra helpers
  // Solve A x = b for square A using Gaussian elimination (small n)
  function solveLinear(A, b) {
    const n = A.length;
    // Augment matrix
    for (let i = 0; i < n; i++) {
      A[i] = A[i].slice();
      A[i].push(b[i]);
    }
    // Forward elimination
    for (let i = 0; i < n; i++) {
      // Pivot
      let maxRow = i;
      for (let r = i + 1; r < n; r++) {
        if (Math.abs(A[r][i]) > Math.abs(A[maxRow][i])) maxRow = r;
      }
      if (Math.abs(A[maxRow][i]) < 1e-12) throw new Error('Singular matrix');
      if (maxRow !== i) {
        const tmp = A[i]; A[i] = A[maxRow]; A[maxRow] = tmp;
      }
      // Normalize row i
      const pivot = A[i][i];
      for (let c = i; c <= n; c++) A[i][c] /= pivot;
      // Eliminate others
      for (let r = 0; r < n; r++) {
        if (r === i) continue;
        const f = A[r][i];
        if (Math.abs(f) < 1e-20) continue;
        for (let c = i; c <= n; c++) A[r][c] -= f * A[i][c];
      }
    }
    // Extract solution
    const x = new Array(n);
    for (let i = 0; i < n; i++) x[i] = A[i][n];
    return x;
  }

  // Least-squares affine from src->dst. Accepts 3 or 4 pairs.
  function computeAffine(srcPts, dstPts) {
    const n = srcPts.length;
    if (n < 3) throw new Error('Need at least 3 points for affine');

    // Build normal equations: (M^T M) p = M^T b
    // For each i: [xi yi 1 0  0  0] [a b c d e f]^T ~= Xi
    //             [0  0  0 xi yi 1]                    Yi
    const rows = 2 * n;
    const M = Array.from({length: rows}, () => Array(6).fill(0));
    const b = new Array(rows);

    for (let i = 0; i < n; i++) {
      const {x, y} = srcPts[i];
      const {x: X, y: Y} = dstPts[i];
      const r = 2 * i;
      M[r][0] = x; M[r][1] = y; M[r][2] = 1; M[r][3] = 0; M[r][4] = 0; M[r][5] = 0;
      b[r] = X;
      M[r+1][0] = 0; M[r+1][1] = 0; M[r+1][2] = 0; M[r+1][3] = x; M[r+1][4] = y; M[r+1][5] = 1;
      b[r+1] = Y;
    }

    // Compute M^T M and M^T b
    const MTM = Array.from({length: 6}, () => Array(6).fill(0));
    const MTb = new Array(6).fill(0);
    for (let r = 0; r < rows; r++) {
      for (let i = 0; i < 6; i++) {
        MTb[i] += M[r][i] * b[r];
        for (let j = 0; j < 6; j++) {
          MTM[i][j] += M[r][i] * M[r][j];
        }
      }
    }

    const p = solveLinear(MTM, MTb); // [a, b, e, c, d, f] careful mapping set above
    // We constructed coefficients as [a,b,e, c,d,f] by block rows. Map to standard:
    const a = p[0], c = p[1], e = p[2], b_ = p[3], d = p[4], f = p[5];
    // Note: mapping is:
    // X = a*x + c*y + e
    // Y = b_*x + d*y + f
    return { a, b: b_, c, d, e, f };
  }

  // Homography from 4 correspondences (src->dst). Fix h33=1 and solve 8x8.
  function computeHomography4(srcPts, dstPts) {
    if (srcPts.length !== 4) throw new Error('Need 4 points for homography');
    const A = [];
    const b = [];
    for (let i = 0; i < 4; i++) {
      const x = srcPts[i].x, y = srcPts[i].y;
      const X = dstPts[i].x, Y = dstPts[i].y;
      // Equations:
      // x h11 + y h12 + h13 - x X h31 - y X h32 = X
      // x h21 + y h22 + h23 - x Y h31 - y Y h32 = Y
      // Unknowns: [h11, h12, h13, h21, h22, h23, h31, h32]
      A.push([x, y, 1, 0, 0, 0, -x*X, -y*X]);
      b.push(X);
      A.push([0, 0, 0, x, y, 1, -x*Y, -y*Y]);
      b.push(Y);
    }
    const h = solveLinear(A, b); // 8x1
    const H = [
      [h[0], h[1], h[2]],
      [h[3], h[4], h[5]],
      [h[6], h[7], 1   ]
    ];
    return H;
  }

  // Apply affine to the overlay SVG image
  function applyAffineToOverlay({a, b, c, d, e, f}) {
    els.svgOverlay.style.transform = `matrix(${a}, ${b}, ${c}, ${d}, ${e}, ${f})`;
    els.svgOverlay.style.transformOrigin = '0 0';
    state.lastApplied = 'affine';
  }

  // Apply homography via CSS matrix3d
  function applyHomographyToOverlay(H) {
    // H =
    // [ h11 h12 h13
    //   h21 h22 h23
    //   h31 h32 h33 ] with h33=1
    const h11 = H[0][0], h12 = H[0][1], h13 = H[0][2];
    const h21 = H[1][0], h22 = H[1][1], h23 = H[1][2];
    const h31 = H[2][0], h32 = H[2][1]; // H[2][2]=1

    // Build 4x4 M that implements 2D homography on z=0 plane:
    // Row-major:
    // [ h11 h12 0 h13
    //   h21 h22 0 h23
    //   0   0   1 0
    //   h31 h32 0 1 ]
    // CSS matrix3d expects column-major argument order:
    const css = [
      h11, h21, 0,   h31,   // col 1
      h12, h22, 0,   h32,   // col 2
      0,   0,   1,   0,     // col 3
      h13, h23, 0,   1      // col 4
    ];
    els.svgOverlay.style.transform = `matrix3d(${css.map(n => Number.isFinite(n) ? n : 0).join(',')})`;
    els.svgOverlay.style.transformOrigin = '0 0';
    state.lastApplied = 'homography';
  }

  // Fit button logic
  els.fitBtn.addEventListener('click', () => {
    const n = state.imgPts.length;
    if (n !== state.svgPts.length || (n !== 3 && n !== 4)) return;

    try {
      if (n === 3 || (n === 4 && els.forceAffine.checked)) {
        const aff = computeAffine(state.svgPts, state.imgPts);
        applyAffineToOverlay(aff);
      } else if (n === 4) {
        const H = computeHomography4(state.svgPts, state.imgPts);
        applyHomographyToOverlay(H);
      }
    } catch (err) {
      console.error(err);
      alert('Fit failed: ' + (err?.message || err));
    }
  });

  // Keep overlay SVG sized like the image (width: 100%). The element already matches by CSS.
  // But make sure opacity matches control on load.
  els.svgOverlay.style.opacity = els.opacity.value;

  // Sync natural aspect: all three panels use the same relative width; layout ensures consistent scaling.
  // No extra code needed unless you programmatically resize columns later.

  // Enable fit button on image/SVG load
  function maybeEnableFitWhenLoaded() {
    const ready = els.imgLeft.complete && els.svgMiddle.complete;
    updateFitButton();
  }
  els.imgLeft.addEventListener('load', maybeEnableFitWhenLoaded);
  els.svgMiddle.addEventListener('load', maybeEnableFitWhenLoaded);
</script>
</body>
</html>